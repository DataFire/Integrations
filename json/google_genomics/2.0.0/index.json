{
  "id": "google_genomics",
  "title": "Genomics",
  "description": "Upload, process, query, and search Genomics data in the cloud.",
  "security": {
    "google_genomics": {
      "integration": "google_genomics",
      "fields": {
        "access_token": "An OAuth access token",
        "refresh_token": "An OAuth refresh token (optional)",
        "client_id": "An OAuth client ID (optional)",
        "client_secret": "An OAuth client secret (optional)"
      },
      "oauth": {
        "authorizationUrl": "https://accounts.google.com/o/oauth2/auth",
        "description": "Oauth 2.0 accessCode authentication",
        "flow": "accessCode",
        "scopes": {
          "https://www.googleapis.com/auth/bigquery": "View and manage your data in Google BigQuery",
          "https://www.googleapis.com/auth/cloud-platform": "View and manage your data across Google Cloud Platform services",
          "https://www.googleapis.com/auth/devstorage.read_write": "Manage your data in Google Cloud Storage",
          "https://www.googleapis.com/auth/genomics": "View and manage Genomics data",
          "https://www.googleapis.com/auth/genomics.readonly": "View Genomics data"
        },
        "tokenUrl": "https://accounts.google.com/o/oauth2/token",
        "type": "oauth2"
      }
    }
  },
  "logo": {
    "url": "https://api.apis.guru/v2/cache/logo/https_www.google.com_images_branding_googlelogo_2x_googlelogo_color_272x92dp.png"
  },
  "tags": [
    "google"
  ],
  "definitions": {
    "Annotation": {
      "description": "An annotation describes a region of reference genome. The value of an\nannotation may be one of several canonical types, supplemented by arbitrary\ninfo tags. An annotation is not inherently associated with a specific\nsample or individual (though a client could choose to use annotations in\nthis way). Example canonical annotation types are `GENE` and\n`VARIANT`.",
      "properties": {
        "annotationSetId": {
          "description": "The annotation set to which this annotation belongs.",
          "type": "string"
        },
        "end": {
          "description": "The end position of the range on the reference, 0-based exclusive.",
          "format": "int64",
          "type": "string"
        },
        "id": {
          "description": "The server-generated annotation ID, unique across all annotations.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional read alignment information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "name": {
          "description": "The display name of this annotation.",
          "type": "string"
        },
        "referenceId": {
          "description": "The ID of the Google Genomics reference associated with this range.",
          "type": "string"
        },
        "referenceName": {
          "description": "The display name corresponding to the reference specified by\n`referenceId`, for example `chr1`, `1`, or `chrX`.",
          "type": "string"
        },
        "reverseStrand": {
          "description": "Whether this range refers to the reverse strand, as opposed to the forward\nstrand. Note that regardless of this field, the start/end position of the\nrange always refer to the forward strand.",
          "type": "boolean"
        },
        "start": {
          "description": "The start position of the range on the reference, 0-based inclusive.",
          "format": "int64",
          "type": "string"
        },
        "transcript": {
          "$ref": "#/definitions/Transcript",
          "description": "A transcript value represents the assertion that a particular region of\nthe reference genome may be transcribed as RNA. An alternative splicing\npattern would be represented as a separate transcript object. This field\nis only set for annotations of type `TRANSCRIPT`."
        },
        "type": {
          "description": "The data type for this annotation. Must match the containing annotation\nset's type.",
          "enum": [
            "ANNOTATION_TYPE_UNSPECIFIED",
            "GENERIC",
            "VARIANT",
            "GENE",
            "TRANSCRIPT"
          ],
          "type": "string"
        },
        "variant": {
          "$ref": "#/definitions/VariantAnnotation",
          "description": "A variant annotation, which describes the effect of a variant on the\ngenome, the coding sequence, and/or higher level consequences at the\norganism level e.g. pathogenicity. This field is only set for annotations\nof type `VARIANT`."
        }
      },
      "type": "object"
    },
    "AnnotationSet": {
      "description": "An annotation set is a logical grouping of annotations that share consistent\ntype information and provenance. Examples of annotation sets include 'all\ngenes from refseq', and 'all variant annotations from ClinVar'.",
      "properties": {
        "datasetId": {
          "description": "The dataset to which this annotation set belongs.",
          "type": "string"
        },
        "id": {
          "description": "The server-generated annotation set ID, unique across all annotation sets.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional read alignment information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "name": {
          "description": "The display name for this annotation set.",
          "type": "string"
        },
        "referenceSetId": {
          "description": "The ID of the reference set that defines the coordinate space for this\nset's annotations.",
          "type": "string"
        },
        "sourceUri": {
          "description": "The source URI describing the file from which this annotation set was\ngenerated, if any.",
          "type": "string"
        },
        "type": {
          "description": "The type of annotations contained within this set.",
          "enum": [
            "ANNOTATION_TYPE_UNSPECIFIED",
            "GENERIC",
            "VARIANT",
            "GENE",
            "TRANSCRIPT"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "BatchCreateAnnotationsRequest": {
      "properties": {
        "annotations": {
          "description": "The annotations to be created. At most 4096 can be specified in a single\nrequest.",
          "items": {
            "$ref": "#/definitions/Annotation"
          },
          "type": "array"
        },
        "requestId": {
          "description": "A unique request ID which enables the server to detect duplicated requests.\nIf provided, duplicated requests will result in the same response; if not\nprovided, duplicated requests may result in duplicated data. For a given\nannotation set, callers should not reuse `request_id`s when writing\ndifferent batches of annotations - behavior in this case is undefined.\nA common approach is to use a UUID. For batch jobs where worker crashes are\na possibility, consider using some unique variant of a worker or run ID.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "BatchCreateAnnotationsResponse": {
      "properties": {
        "entries": {
          "description": "The resulting per-annotation entries, ordered consistently with the\noriginal request.",
          "items": {
            "$ref": "#/definitions/Entry"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "Binding": {
      "description": "Associates `members` with a `role`.",
      "properties": {
        "members": {
          "description": "Specifies the identities requesting access for a Cloud Platform resource.\n`members` can have the following values:\n\n* `allUsers`: A special identifier that represents anyone who is\n   on the internet; with or without a Google account.\n\n* `allAuthenticatedUsers`: A special identifier that represents anyone\n   who is authenticated with a Google account or a service account.\n\n* `user:{emailid}`: An email address that represents a specific Google\n   account. For example, `alice@gmail.com` or `joe@example.com`.\n\n\n* `serviceAccount:{emailid}`: An email address that represents a service\n   account. For example, `my-other-app@appspot.gserviceaccount.com`.\n\n* `group:{emailid}`: An email address that represents a Google group.\n   For example, `admins@example.com`.\n\n* `domain:{domain}`: A Google Apps domain name that represents all the\n   users of that domain. For example, `google.com` or `example.com`.\n\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "role": {
          "description": "Role that is assigned to `members`.\nFor example, `roles/viewer`, `roles/editor`, or `roles/owner`.\nRequired",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CallSet": {
      "description": "A call set is a collection of variant calls, typically for one sample. It\nbelongs to a variant set.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "created": {
          "description": "The date this call set was created in milliseconds from the epoch.",
          "format": "int64",
          "type": "string"
        },
        "id": {
          "description": "The server-generated call set ID, unique across all call sets.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional call set information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "name": {
          "description": "The call set name.",
          "type": "string"
        },
        "sampleId": {
          "description": "The sample ID this call set corresponds to.",
          "type": "string"
        },
        "variantSetIds": {
          "description": "The IDs of the variant sets this call set belongs to. This field must\nhave exactly length one, as a call set belongs to a single variant set.\nThis field is repeated for compatibility with the\n[GA4GH 0.5.1\nAPI](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "CancelOperationRequest": {
      "description": "The request message for Operations.CancelOperation.",
      "properties": {},
      "type": "object"
    },
    "CigarUnit": {
      "description": "A single CIGAR operation.",
      "properties": {
        "operation": {
          "enum": [
            "OPERATION_UNSPECIFIED",
            "ALIGNMENT_MATCH",
            "INSERT",
            "DELETE",
            "SKIP",
            "CLIP_SOFT",
            "CLIP_HARD",
            "PAD",
            "SEQUENCE_MATCH",
            "SEQUENCE_MISMATCH"
          ],
          "type": "string"
        },
        "operationLength": {
          "description": "The number of genomic bases that the operation runs for. Required.",
          "format": "int64",
          "type": "string"
        },
        "referenceSequence": {
          "description": "`referenceSequence` is only used at mismatches\n(`SEQUENCE_MISMATCH`) and deletions (`DELETE`).\nFilling this field replaces SAM's MD tag. If the relevant information is\nnot available, this field is unset.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ClinicalCondition": {
      "properties": {
        "conceptId": {
          "description": "The MedGen concept id associated with this gene.\nSearch for these IDs at http://www.ncbi.nlm.nih.gov/medgen/",
          "type": "string"
        },
        "externalIds": {
          "description": "The set of external IDs for this condition.",
          "items": {
            "$ref": "#/definitions/ExternalId"
          },
          "type": "array"
        },
        "names": {
          "description": "A set of names for the condition.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "omimId": {
          "description": "The OMIM id for this condition.\nSearch for these IDs at http://omim.org/",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CodingSequence": {
      "properties": {
        "end": {
          "description": "The end of the coding sequence on this annotation's reference sequence,\n0-based exclusive. Note that this position is relative to the reference\nstart, and *not* the containing annotation start.",
          "format": "int64",
          "type": "string"
        },
        "start": {
          "description": "The start of the coding sequence on this annotation's reference sequence,\n0-based inclusive. Note that this position is relative to the reference\nstart, and *not* the containing annotation start.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ComputeEngine": {
      "description": "Describes a Compute Engine resource that is being managed by a running\npipeline.",
      "properties": {
        "diskNames": {
          "description": "The names of the disks that were created for this pipeline.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "instanceName": {
          "description": "The instance on which the operation is running.",
          "type": "string"
        },
        "machineType": {
          "description": "The machine type of the instance.",
          "type": "string"
        },
        "zone": {
          "description": "The availability zone in which the instance resides.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CoverageBucket": {
      "description": "A bucket over which read coverage has been precomputed. A bucket corresponds\nto a specific range of the reference sequence.",
      "properties": {
        "meanCoverage": {
          "description": "The average number of reads which are aligned to each individual\nreference base in this bucket.",
          "format": "float",
          "type": "number"
        },
        "range": {
          "$ref": "#/definitions/Range",
          "description": "The genomic coordinate range spanned by this bucket."
        }
      },
      "type": "object"
    },
    "Dataset": {
      "description": "A Dataset is a collection of genomic data.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "createTime": {
          "description": "The time this dataset was created, in seconds from the epoch.",
          "format": "google-datetime",
          "type": "string"
        },
        "id": {
          "description": "The server-generated dataset ID, unique across all datasets.",
          "type": "string"
        },
        "name": {
          "description": "The dataset name.",
          "type": "string"
        },
        "projectId": {
          "description": "The Google Cloud project ID that this dataset belongs to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Empty": {
      "description": "A generic empty message that you can re-use to avoid defining duplicated\nempty messages in your APIs. A typical example is to use it as the request\nor the response type of an API method. For instance:\n\n    service Foo {\n      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n    }\n\nThe JSON representation for `Empty` is empty JSON object `{}`.",
      "properties": {},
      "type": "object"
    },
    "Entry": {
      "properties": {
        "annotation": {
          "$ref": "#/definitions/Annotation",
          "description": "The created annotation, if creation was successful."
        },
        "status": {
          "$ref": "#/definitions/Status",
          "description": "The creation status."
        }
      },
      "type": "object"
    },
    "Exon": {
      "properties": {
        "end": {
          "description": "The end position of the exon on this annotation's reference sequence,\n0-based exclusive. Note that this is relative to the reference start, and\n*not* the containing annotation start.",
          "format": "int64",
          "type": "string"
        },
        "frame": {
          "description": "The frame of this exon. Contains a value of 0, 1, or 2, which indicates\nthe offset of the first coding base of the exon within the reading frame\nof the coding DNA sequence, if any. This field is dependent on the\nstrandedness of this annotation (see\nAnnotation.reverse_strand).\nFor forward stranded annotations, this offset is relative to the\nexon.start. For reverse\nstrand annotations, this offset is relative to the\nexon.end `- 1`.\n\nUnset if this exon does not intersect the coding sequence. Upon creation\nof a transcript, the frame must be populated for all or none of the\ncoding exons.",
          "format": "int32",
          "type": "integer"
        },
        "start": {
          "description": "The start position of the exon on this annotation's reference sequence,\n0-based inclusive. Note that this is relative to the reference start, and\n**not** the containing annotation start.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Experiment": {
      "properties": {
        "instrumentModel": {
          "description": "The instrument model used as part of this experiment. This maps to\nsequencing technology in the SAM spec.",
          "type": "string"
        },
        "libraryId": {
          "description": "A client-supplied library identifier; a library is a collection of DNA\nfragments which have been prepared for sequencing from a sample. This\nfield is important for quality control as error or bias can be introduced\nduring sample preparation.",
          "type": "string"
        },
        "platformUnit": {
          "description": "The platform unit used as part of this experiment, for example\nflowcell-barcode.lane for Illumina or slide for SOLiD. Corresponds to the\n@RG PU field in the SAM spec.",
          "type": "string"
        },
        "sequencingCenter": {
          "description": "The sequencing center used as part of this experiment.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ExportReadGroupSetRequest": {
      "description": "The read group set export request.",
      "properties": {
        "exportUri": {
          "description": "Required. A Google Cloud Storage URI for the exported BAM file.\nThe currently authenticated user must have write access to the new file.\nAn error will be returned if the URI already contains data.",
          "type": "string"
        },
        "projectId": {
          "description": "Required. The Google Cloud project ID that owns this\nexport. The caller must have WRITE access to this project.",
          "type": "string"
        },
        "referenceNames": {
          "description": "The reference names to export. If this is not specified, all reference\nsequences, including unmapped reads, are exported.\nUse `*` to export only unmapped reads.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ExportVariantSetRequest": {
      "description": "The variant data export request.",
      "properties": {
        "bigqueryDataset": {
          "description": "Required. The BigQuery dataset to export data to. This dataset must already\nexist. Note that this is distinct from the Genomics concept of \"dataset\".",
          "type": "string"
        },
        "bigqueryTable": {
          "description": "Required. The BigQuery table to export data to.\nIf the table doesn't exist, it will be created. If it already exists, it\nwill be overwritten.",
          "type": "string"
        },
        "callSetIds": {
          "description": "If provided, only variant call information from the specified call sets\nwill be exported. By default all variant calls are exported.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "format": {
          "description": "The format for the exported data.",
          "enum": [
            "FORMAT_UNSPECIFIED",
            "FORMAT_BIGQUERY"
          ],
          "type": "string"
        },
        "projectId": {
          "description": "Required. The Google Cloud project ID that owns the destination\nBigQuery dataset. The caller must have WRITE access to this project.  This\nproject will also own the resulting export job.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ExternalId": {
      "properties": {
        "id": {
          "description": "The id used by the source of this data.",
          "type": "string"
        },
        "sourceName": {
          "description": "The name of the source of this data.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetIamPolicyRequest": {
      "description": "Request message for `GetIamPolicy` method.",
      "properties": {},
      "type": "object"
    },
    "ImportReadGroupSetsRequest": {
      "description": "The read group set import request.",
      "properties": {
        "datasetId": {
          "description": "Required. The ID of the dataset these read group sets will belong to. The\ncaller must have WRITE permissions to this dataset.",
          "type": "string"
        },
        "partitionStrategy": {
          "description": "The partition strategy describes how read groups are partitioned into read\ngroup sets.",
          "enum": [
            "PARTITION_STRATEGY_UNSPECIFIED",
            "PER_FILE_PER_SAMPLE",
            "MERGE_ALL"
          ],
          "type": "string"
        },
        "referenceSetId": {
          "description": "The reference set to which the imported read group sets are aligned to, if\nany. The reference names of this reference set must be a superset of those\nfound in the imported file headers. If no reference set id is provided, a\nbest effort is made to associate with a matching reference set.",
          "type": "string"
        },
        "sourceUris": {
          "description": "A list of URIs pointing at [BAM\nfiles](https://samtools.github.io/hts-specs/SAMv1.pdf)\nin Google Cloud Storage.\nThose URIs can include wildcards (*), but do not add or remove\nmatching files before import has completed.\n\nNote that Google Cloud Storage object listing is only eventually\nconsistent: files added may be not be immediately visible to\neveryone. Thus, if using a wildcard it is preferable not to start\nthe import immediately after the files are created.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ImportReadGroupSetsResponse": {
      "description": "The read group set import response.",
      "properties": {
        "readGroupSetIds": {
          "description": "IDs of the read group sets that were created.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ImportVariantsRequest": {
      "description": "The variant data import request.",
      "properties": {
        "format": {
          "description": "The format of the variant data being imported. If unspecified, defaults to\nto `VCF`.",
          "enum": [
            "FORMAT_UNSPECIFIED",
            "FORMAT_VCF",
            "FORMAT_COMPLETE_GENOMICS"
          ],
          "type": "string"
        },
        "infoMergeConfig": {
          "additionalProperties": {
            "enum": [
              "INFO_MERGE_OPERATION_UNSPECIFIED",
              "IGNORE_NEW",
              "MOVE_TO_CALLS"
            ],
            "type": "string"
          },
          "description": "A mapping between info field keys and the InfoMergeOperations to\nbe performed on them. This is plumbed down to the MergeVariantRequests\ngenerated by the resulting import job.",
          "type": "object"
        },
        "normalizeReferenceNames": {
          "description": "Convert reference names to the canonical representation.\nhg19 haploytypes (those reference names containing \"_hap\")\nare not modified in any way.\nAll other reference names are modified according to the following rules:\nThe reference name is capitalized.\nThe \"chr\" prefix is dropped for all autosomes and sex chromsomes.\nFor example \"chr17\" becomes \"17\" and \"chrX\" becomes \"X\".\nAll mitochondrial chromosomes (\"chrM\", \"chrMT\", etc) become \"MT\".",
          "type": "boolean"
        },
        "sourceUris": {
          "description": "A list of URIs referencing variant files in Google Cloud Storage. URIs can\ninclude wildcards [as described\nhere](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).\nNote that recursive wildcards ('**') are not supported.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "variantSetId": {
          "description": "Required. The variant set to which variant data should be imported.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ImportVariantsResponse": {
      "description": "The variant data import response.",
      "properties": {
        "callSetIds": {
          "description": "IDs of the call sets created during the import.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LinearAlignment": {
      "description": "A linear alignment can be represented by one CIGAR string. Describes the\nmapped position and local alignment of the read to the reference.",
      "properties": {
        "cigar": {
          "description": "Represents the local alignment of this sequence (alignment matches, indels,\netc) against the reference.",
          "items": {
            "$ref": "#/definitions/CigarUnit"
          },
          "type": "array"
        },
        "mappingQuality": {
          "description": "The mapping quality of this alignment. Represents how likely\nthe read maps to this position as opposed to other locations.\n\nSpecifically, this is -10 log10 Pr(mapping position is wrong), rounded to\nthe nearest integer.",
          "format": "int32",
          "type": "integer"
        },
        "position": {
          "$ref": "#/definitions/Position",
          "description": "The position of this alignment."
        }
      },
      "type": "object"
    },
    "ListBasesResponse": {
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "offset": {
          "description": "The offset position (0-based) of the given `sequence` from the\nstart of this `Reference`. This value will differ for each page\nin a paginated request.",
          "format": "int64",
          "type": "string"
        },
        "sequence": {
          "description": "A substring of the bases that make up this reference.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ListCoverageBucketsResponse": {
      "properties": {
        "bucketWidth": {
          "description": "The length of each coverage bucket in base pairs. Note that buckets at the\nend of a reference sequence may be shorter. This value is omitted if the\nbucket width is infinity (the default behaviour, with no range or\n`targetBucketWidth`).",
          "format": "int64",
          "type": "string"
        },
        "coverageBuckets": {
          "description": "The coverage buckets. The list of buckets is sparse; a bucket with 0\noverlapping reads is not returned. A bucket never crosses more than one\nreference sequence. Each bucket has width `bucketWidth`, unless\nits end is the end of the reference sequence.",
          "items": {
            "$ref": "#/definitions/CoverageBucket"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ListDatasetsResponse": {
      "description": "The dataset list response.",
      "properties": {
        "datasets": {
          "description": "The list of matching Datasets.",
          "items": {
            "$ref": "#/definitions/Dataset"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ListOperationsResponse": {
      "description": "The response message for Operations.ListOperations.",
      "properties": {
        "nextPageToken": {
          "description": "The standard List next-page token.",
          "type": "string"
        },
        "operations": {
          "description": "A list of operations that matches the specified filter in the request.",
          "items": {
            "$ref": "#/definitions/Operation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MergeVariantsRequest": {
      "properties": {
        "infoMergeConfig": {
          "additionalProperties": {
            "enum": [
              "INFO_MERGE_OPERATION_UNSPECIFIED",
              "IGNORE_NEW",
              "MOVE_TO_CALLS"
            ],
            "type": "string"
          },
          "description": "A mapping between info field keys and the InfoMergeOperations to\nbe performed on them.",
          "type": "object"
        },
        "variantSetId": {
          "description": "The destination variant set.",
          "type": "string"
        },
        "variants": {
          "description": "The variants to be merged with existing variants.",
          "items": {
            "$ref": "#/definitions/Variant"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "Operation": {
      "description": "This resource represents a long-running operation that is the result of a\nnetwork API call.",
      "properties": {
        "done": {
          "description": "If the value is `false`, it means the operation is still in progress.\nIf true, the operation is completed, and either `error` or `response` is\navailable.",
          "type": "boolean"
        },
        "error": {
          "$ref": "#/definitions/Status",
          "description": "The error result of the operation in case of failure or cancellation."
        },
        "metadata": {
          "additionalProperties": {
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "description": "An OperationMetadata object. This will always be returned with the Operation.",
          "type": "object"
        },
        "name": {
          "description": "The server-assigned name, which is only unique within the same service that originally returns it. For example&#58; `operations/CJHU7Oi_ChDrveSpBRjfuL-qzoWAgEw`",
          "type": "string"
        },
        "response": {
          "additionalProperties": {
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "description": "If importing ReadGroupSets, an ImportReadGroupSetsResponse is returned. If importing Variants, an ImportVariantsResponse is returned. For pipelines and exports, an empty response is returned.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "OperationEvent": {
      "description": "An event that occurred during an Operation.",
      "properties": {
        "description": {
          "description": "Required description of event.",
          "type": "string"
        },
        "endTime": {
          "description": "Optional time of when event finished. An event can have a start time and no\nfinish time. If an event has a finish time, there must be a start time.",
          "format": "google-datetime",
          "type": "string"
        },
        "startTime": {
          "description": "Optional time of when event started.",
          "format": "google-datetime",
          "type": "string"
        }
      },
      "type": "object"
    },
    "OperationMetadata": {
      "description": "Metadata describing an Operation.",
      "properties": {
        "clientId": {
          "description": "This field is deprecated. Use `labels` instead. Optionally provided by the\ncaller when submitting the request that creates the operation.",
          "type": "string"
        },
        "createTime": {
          "description": "The time at which the job was submitted to the Genomics service.",
          "format": "google-datetime",
          "type": "string"
        },
        "endTime": {
          "description": "The time at which the job stopped running.",
          "format": "google-datetime",
          "type": "string"
        },
        "events": {
          "description": "Optional event messages that were generated during the job's execution.\nThis also contains any warnings that were generated during import\nor export.",
          "items": {
            "$ref": "#/definitions/OperationEvent"
          },
          "type": "array"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optionally provided by the caller when submitting the request that creates\nthe operation.",
          "type": "object"
        },
        "projectId": {
          "description": "The Google Cloud Project in which the job is scoped.",
          "type": "string"
        },
        "request": {
          "additionalProperties": {
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "description": "The original request that started the operation. Note that this will be in\ncurrent version of the API. If the operation was started with v1beta2 API\nand a GetOperation is performed on v1 API, a v1 request will be returned.",
          "type": "object"
        },
        "runtimeMetadata": {
          "additionalProperties": {
            "description": "Properties of the object. Contains field @type with type URL."
          },
          "description": "Runtime metadata on this Operation.",
          "type": "object"
        },
        "startTime": {
          "description": "The time at which the job began to run.",
          "format": "google-datetime",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Policy": {
      "description": "Defines an Identity and Access Management (IAM) policy. It is used to\nspecify access control policies for Cloud Platform resources.\n\n\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\n`members` to a `role`, where the members can be user accounts, Google groups,\nGoogle domains, and service accounts. A `role` is a named list of permissions\ndefined by IAM.\n\n**Example**\n\n    {\n      \"bindings\": [\n        {\n          \"role\": \"roles/owner\",\n          \"members\": [\n            \"user:mike@example.com\",\n            \"group:admins@example.com\",\n            \"domain:google.com\",\n            \"serviceAccount:my-other-app@appspot.gserviceaccount.com\",\n          ]\n        },\n        {\n          \"role\": \"roles/viewer\",\n          \"members\": [\"user:sean@example.com\"]\n        }\n      ]\n    }\n\nFor a description of IAM and its features, see the\n[IAM developer's guide](https://cloud.google.com/iam).",
      "properties": {
        "bindings": {
          "description": "Associates a list of `members` to a `role`.\nMultiple `bindings` must not be specified for the same `role`.\n`bindings` with no members will result in an error.",
          "items": {
            "$ref": "#/definitions/Binding"
          },
          "type": "array"
        },
        "etag": {
          "description": "`etag` is used for optimistic concurrency control as a way to help\nprevent simultaneous updates of a policy from overwriting each other.\nIt is strongly suggested that systems make use of the `etag` in the\nread-modify-write cycle to perform policy updates in order to avoid race\nconditions: An `etag` is returned in the response to `getIamPolicy`, and\nsystems are expected to put that etag in the request to `setIamPolicy` to\nensure that their change will be applied to the same version of the policy.\n\nIf no `etag` is provided in the call to `setIamPolicy`, then the existing\npolicy is overwritten blindly.",
          "format": "byte",
          "type": "string"
        },
        "version": {
          "description": "Version of the `Policy`. The default version is 0.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "Position": {
      "description": "An abstraction for referring to a genomic position, in relation to some\nalready known reference. For now, represents a genomic position as a\nreference name, a base number on that reference (0-based), and a\ndetermination of forward or reverse strand.",
      "properties": {
        "position": {
          "description": "The 0-based offset from the start of the forward strand for that reference.",
          "format": "int64",
          "type": "string"
        },
        "referenceName": {
          "description": "The name of the reference in whatever reference set is being used.",
          "type": "string"
        },
        "reverseStrand": {
          "description": "Whether this position is on the reverse strand, as opposed to the forward\nstrand.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Program": {
      "properties": {
        "commandLine": {
          "description": "The command line used to run this program.",
          "type": "string"
        },
        "id": {
          "description": "The user specified locally unique ID of the program. Used along with\n`prevProgramId` to define an ordering between programs.",
          "type": "string"
        },
        "name": {
          "description": "The display name of the program. This is typically the colloquial name of\nthe tool used, for example 'bwa' or 'picard'.",
          "type": "string"
        },
        "prevProgramId": {
          "description": "The ID of the program run before this one.",
          "type": "string"
        },
        "version": {
          "description": "The version of the program run.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Range": {
      "description": "A 0-based half-open genomic coordinate range for search requests.",
      "properties": {
        "end": {
          "description": "The end position of the range on the reference, 0-based exclusive.",
          "format": "int64",
          "type": "string"
        },
        "referenceName": {
          "description": "The reference sequence name, for example `chr1`,\n`1`, or `chrX`.",
          "type": "string"
        },
        "start": {
          "description": "The start position of the range on the reference, 0-based inclusive.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Read": {
      "description": "A read alignment describes a linear alignment of a string of DNA to a\nreference sequence, in addition to metadata\nabout the fragment (the molecule of DNA sequenced) and the read (the bases\nwhich were read by the sequencer). A read is equivalent to a line in a SAM\nfile. A read belongs to exactly one read group and exactly one\nread group set.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\n### Reverse-stranded reads\n\nMapped reads (reads having a non-null `alignment`) can be aligned to either\nthe forward or the reverse strand of their associated reference. Strandedness\nof a mapped read is encoded by `alignment.position.reverseStrand`.\n\nIf we consider the reference to be a forward-stranded coordinate space of\n`[0, reference.length)` with `0` as the left-most position and\n`reference.length` as the right-most position, reads are always aligned left\nto right. That is, `alignment.position.position` always refers to the\nleft-most reference coordinate and `alignment.cigar` describes the alignment\nof this read to the reference from left to right. All per-base fields such as\n`alignedSequence` and `alignedQuality` share this same left-to-right\norientation; this is true of reads which are aligned to either strand. For\nreverse-stranded reads, this means that `alignedSequence` is the reverse\ncomplement of the bases that were originally reported by the sequencing\nmachine.\n\n### Generating a reference-aligned sequence string\n\nWhen interacting with mapped reads, it's often useful to produce a string\nrepresenting the local alignment of the read to reference. The following\npseudocode demonstrates one way of doing this:\n\n    out = \"\"\n    offset = 0\n    for c in read.alignment.cigar {\n      switch c.operation {\n      case \"ALIGNMENT_MATCH\", \"SEQUENCE_MATCH\", \"SEQUENCE_MISMATCH\":\n        out += read.alignedSequence[offset:offset+c.operationLength]\n        offset += c.operationLength\n        break\n      case \"CLIP_SOFT\", \"INSERT\":\n        offset += c.operationLength\n        break\n      case \"PAD\":\n        out += repeat(\"*\", c.operationLength)\n        break\n      case \"DELETE\":\n        out += repeat(\"-\", c.operationLength)\n        break\n      case \"SKIP\":\n        out += repeat(\" \", c.operationLength)\n        break\n      case \"CLIP_HARD\":\n        break\n      }\n    }\n    return out\n\n### Converting to SAM's CIGAR string\n\nThe following pseudocode generates a SAM CIGAR string from the\n`cigar` field. Note that this is a lossy conversion\n(`cigar.referenceSequence` is lost).\n\n    cigarMap = {\n      \"ALIGNMENT_MATCH\": \"M\",\n      \"INSERT\": \"I\",\n      \"DELETE\": \"D\",\n      \"SKIP\": \"N\",\n      \"CLIP_SOFT\": \"S\",\n      \"CLIP_HARD\": \"H\",\n      \"PAD\": \"P\",\n      \"SEQUENCE_MATCH\": \"=\",\n      \"SEQUENCE_MISMATCH\": \"X\",\n    }\n    cigarStr = \"\"\n    for c in read.alignment.cigar {\n      cigarStr += c.operationLength + cigarMap[c.operation]\n    }\n    return cigarStr",
      "properties": {
        "alignedQuality": {
          "description": "The quality of the read sequence contained in this alignment record\n(equivalent to QUAL in SAM).\n`alignedSequence` and `alignedQuality` may be shorter than the full read\nsequence and quality. This will occur if the alignment is part of a\nchimeric alignment, or if the read was trimmed. When this occurs, the CIGAR\nfor this read will begin/end with a hard clip operator that will indicate\nthe length of the excised sequence.",
          "items": {
            "format": "int32",
            "type": "integer"
          },
          "type": "array"
        },
        "alignedSequence": {
          "description": "The bases of the read sequence contained in this alignment record,\n**without CIGAR operations applied** (equivalent to SEQ in SAM).\n`alignedSequence` and `alignedQuality` may be\nshorter than the full read sequence and quality. This will occur if the\nalignment is part of a chimeric alignment, or if the read was trimmed. When\nthis occurs, the CIGAR for this read will begin/end with a hard clip\noperator that will indicate the length of the excised sequence.",
          "type": "string"
        },
        "alignment": {
          "$ref": "#/definitions/LinearAlignment",
          "description": "The linear alignment for this alignment record. This field is null for\nunmapped reads."
        },
        "duplicateFragment": {
          "description": "The fragment is a PCR or optical duplicate (SAM flag 0x400).",
          "type": "boolean"
        },
        "failedVendorQualityChecks": {
          "description": "Whether this read did not pass filters, such as platform or vendor quality\ncontrols (SAM flag 0x200).",
          "type": "boolean"
        },
        "fragmentLength": {
          "description": "The observed length of the fragment, equivalent to TLEN in SAM.",
          "format": "int32",
          "type": "integer"
        },
        "fragmentName": {
          "description": "The fragment name. Equivalent to QNAME (query template name) in SAM.",
          "type": "string"
        },
        "id": {
          "description": "The server-generated read ID, unique across all reads. This is different\nfrom the `fragmentName`.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional read alignment information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "nextMatePosition": {
          "$ref": "#/definitions/Position",
          "description": "The mapping of the primary alignment of the\n`(readNumber+1)%numberReads` read in the fragment. It replaces\nmate position and mate strand in SAM."
        },
        "numberReads": {
          "description": "The number of reads in the fragment (extension to SAM flag 0x1).",
          "format": "int32",
          "type": "integer"
        },
        "properPlacement": {
          "description": "The orientation and the distance between reads from the fragment are\nconsistent with the sequencing protocol (SAM flag 0x2).",
          "type": "boolean"
        },
        "readGroupId": {
          "description": "The ID of the read group this read belongs to. A read belongs to exactly\none read group. This is a server-generated ID which is distinct from SAM's\nRG tag (for that value, see\nReadGroup.name).",
          "type": "string"
        },
        "readGroupSetId": {
          "description": "The ID of the read group set this read belongs to. A read belongs to\nexactly one read group set.",
          "type": "string"
        },
        "readNumber": {
          "description": "The read number in sequencing. 0-based and less than numberReads. This\nfield replaces SAM flag 0x40 and 0x80.",
          "format": "int32",
          "type": "integer"
        },
        "secondaryAlignment": {
          "description": "Whether this alignment is secondary. Equivalent to SAM flag 0x100.\nA secondary alignment represents an alternative to the primary alignment\nfor this read. Aligners may return secondary alignments if a read can map\nambiguously to multiple coordinates in the genome. By convention, each read\nhas one and only one alignment where both `secondaryAlignment`\nand `supplementaryAlignment` are false.",
          "type": "boolean"
        },
        "supplementaryAlignment": {
          "description": "Whether this alignment is supplementary. Equivalent to SAM flag 0x800.\nSupplementary alignments are used in the representation of a chimeric\nalignment. In a chimeric alignment, a read is split into multiple\nlinear alignments that map to different reference contigs. The first\nlinear alignment in the read will be designated as the representative\nalignment; the remaining linear alignments will be designated as\nsupplementary alignments. These alignments may have different mapping\nquality scores. In each linear alignment in a chimeric alignment, the read\nwill be hard clipped. The `alignedSequence` and\n`alignedQuality` fields in the alignment record will only\nrepresent the bases for its respective linear alignment.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ReadGroup": {
      "description": "A read group is all the data that's processed the same way by the sequencer.",
      "properties": {
        "datasetId": {
          "description": "The dataset to which this read group belongs.",
          "type": "string"
        },
        "description": {
          "description": "A free-form text description of this read group.",
          "type": "string"
        },
        "experiment": {
          "$ref": "#/definitions/Experiment",
          "description": "The experiment used to generate this read group."
        },
        "id": {
          "description": "The server-generated read group ID, unique for all read groups.\nNote: This is different than the @RG ID field in the SAM spec. For that\nvalue, see name.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional read group information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "name": {
          "description": "The read group name. This corresponds to the @RG ID field in the SAM spec.",
          "type": "string"
        },
        "predictedInsertSize": {
          "description": "The predicted insert size of this read group. The insert size is the length\nthe sequenced DNA fragment from end-to-end, not including the adapters.",
          "format": "int32",
          "type": "integer"
        },
        "programs": {
          "description": "The programs used to generate this read group. Programs are always\nidentical for all read groups within a read group set. For this reason,\nonly the first read group in a returned set will have this field\npopulated.",
          "items": {
            "$ref": "#/definitions/Program"
          },
          "type": "array"
        },
        "referenceSetId": {
          "description": "The reference set the reads in this read group are aligned to.",
          "type": "string"
        },
        "sampleId": {
          "description": "A client-supplied sample identifier for the reads in this read group.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReadGroupSet": {
      "description": "A read group set is a logical collection of read groups, which are\ncollections of reads produced by a sequencer. A read group set typically\nmodels reads corresponding to one sample, sequenced one way, and aligned one\nway.\n\n* A read group set belongs to one dataset.\n* A read group belongs to one read group set.\n* A read belongs to one read group.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "datasetId": {
          "description": "The dataset to which this read group set belongs.",
          "type": "string"
        },
        "filename": {
          "description": "The filename of the original source file for this read group set, if any.",
          "type": "string"
        },
        "id": {
          "description": "The server-generated read group set ID, unique for all read group sets.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional read group set information.",
          "type": "object"
        },
        "name": {
          "description": "The read group set name. By default this will be initialized to the sample\nname of the sequenced data contained in this set.",
          "type": "string"
        },
        "readGroups": {
          "description": "The read groups in this set. There are typically 1-10 read groups in a read\ngroup set.",
          "items": {
            "$ref": "#/definitions/ReadGroup"
          },
          "type": "array"
        },
        "referenceSetId": {
          "description": "The reference set to which the reads in this read group set are aligned.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Reference": {
      "description": "A reference is a canonical assembled DNA sequence, intended to act as a\nreference coordinate space for other genomic annotations. A single reference\nmight represent the human chromosome 1 or mitochandrial DNA, for instance. A\nreference belongs to one or more reference sets.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "id": {
          "description": "The server-generated reference ID, unique across all references.",
          "type": "string"
        },
        "length": {
          "description": "The length of this reference's sequence.",
          "format": "int64",
          "type": "string"
        },
        "md5checksum": {
          "description": "MD5 of the upper-case sequence excluding all whitespace characters (this\nis equivalent to SQ:M5 in SAM). This value is represented in lower case\nhexadecimal format.",
          "type": "string"
        },
        "name": {
          "description": "The name of this reference, for example `22`.",
          "type": "string"
        },
        "ncbiTaxonId": {
          "description": "ID from http://www.ncbi.nlm.nih.gov/taxonomy. For example, 9606 for human.",
          "format": "int32",
          "type": "integer"
        },
        "sourceAccessions": {
          "description": "All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally\nwith a version number, for example `GCF_000001405.26`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "sourceUri": {
          "description": "The URI from which the sequence was obtained. Typically specifies a FASTA\nformat file.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReferenceBound": {
      "description": "ReferenceBound records an upper bound for the starting coordinate of\nvariants in a particular reference.",
      "properties": {
        "referenceName": {
          "description": "The name of the reference associated with this reference bound.",
          "type": "string"
        },
        "upperBound": {
          "description": "An upper bound (inclusive) on the starting coordinate of any\nvariant in the reference sequence.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReferenceSet": {
      "description": "A reference set is a set of references which typically comprise a reference\nassembly for a species, such as `GRCh38` which is representative\nof the human genome. A reference set defines a common coordinate space for\ncomparing reference-aligned experimental data. A reference set contains 1 or\nmore references.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "assemblyId": {
          "description": "Public id of this reference set, such as `GRCh37`.",
          "type": "string"
        },
        "description": {
          "description": "Free text description of this reference set.",
          "type": "string"
        },
        "id": {
          "description": "The server-generated reference set ID, unique across all reference sets.",
          "type": "string"
        },
        "md5checksum": {
          "description": "Order-independent MD5 checksum which identifies this reference set. The\nchecksum is computed by sorting all lower case hexidecimal string\n`reference.md5checksum` (for all reference in this set) in\nascending lexicographic order, concatenating, and taking the MD5 of that\nvalue. The resulting value is represented in lower case hexadecimal format.",
          "type": "string"
        },
        "ncbiTaxonId": {
          "description": "ID from http://www.ncbi.nlm.nih.gov/taxonomy (for example, 9606 for human)\nindicating the species which this reference set is intended to model. Note\nthat contained references may specify a different `ncbiTaxonId`, as\nassemblies may contain reference sequences which do not belong to the\nmodeled species, for example EBV in a human reference genome.",
          "format": "int32",
          "type": "integer"
        },
        "referenceIds": {
          "description": "The IDs of the reference objects that are part of this set.\n`Reference.md5checksum` must be unique within this set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "sourceAccessions": {
          "description": "All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally\nwith a version number, for example `NC_000001.11`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "sourceUri": {
          "description": "The URI from which the references were obtained.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RuntimeMetadata": {
      "description": "Runtime metadata that will be populated in the\nruntimeMetadata\nfield of the Operation associated with a RunPipeline execution.",
      "properties": {
        "computeEngine": {
          "$ref": "#/definitions/ComputeEngine",
          "description": "Execution information specific to Google Compute Engine."
        }
      },
      "type": "object"
    },
    "SearchAnnotationSetsRequest": {
      "properties": {
        "datasetIds": {
          "description": "Required. The dataset IDs to search within. Caller must have `READ` access\nto these datasets.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "description": "Only return annotations sets for which a substring of the name matches this\nstring (case insensitive).",
          "type": "string"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 128. The maximum value is 1024.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "referenceSetId": {
          "description": "If specified, only annotation sets associated with the given reference set\nare returned.",
          "type": "string"
        },
        "types": {
          "description": "If specified, only annotation sets that have any of these types are\nreturned.",
          "items": {
            "enum": [
              "ANNOTATION_TYPE_UNSPECIFIED",
              "GENERIC",
              "VARIANT",
              "GENE",
              "TRANSCRIPT"
            ],
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchAnnotationSetsResponse": {
      "properties": {
        "annotationSets": {
          "description": "The matching annotation sets.",
          "items": {
            "$ref": "#/definitions/AnnotationSet"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchAnnotationsRequest": {
      "properties": {
        "annotationSetIds": {
          "description": "Required. The annotation sets to search within. The caller must have\n`READ` access to these annotation sets.\nAll queried annotation sets must have the same type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "end": {
          "description": "The end position of the range on the reference, 0-based exclusive. If\nreferenceId or\nreferenceName\nmust be specified, Defaults to the length of the reference.",
          "format": "int64",
          "type": "string"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 256. The maximum value is 2048.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "referenceId": {
          "description": "The ID of the reference to query.",
          "type": "string"
        },
        "referenceName": {
          "description": "The name of the reference to query, within the reference set associated\nwith this query.",
          "type": "string"
        },
        "start": {
          "description": "The start position of the range on the reference, 0-based inclusive. If\nspecified,\nreferenceId or\nreferenceName\nmust be specified. Defaults to 0.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchAnnotationsResponse": {
      "properties": {
        "annotations": {
          "description": "The matching annotations.",
          "items": {
            "$ref": "#/definitions/Annotation"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchCallSetsRequest": {
      "description": "The call set search request.",
      "properties": {
        "name": {
          "description": "Only return call sets for which a substring of the name matches this\nstring.",
          "type": "string"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 1024.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "variantSetIds": {
          "description": "Restrict the query to call sets within the given variant sets. At least one\nID must be provided.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchCallSetsResponse": {
      "description": "The call set search response.",
      "properties": {
        "callSets": {
          "description": "The list of matching call sets.",
          "items": {
            "$ref": "#/definitions/CallSet"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReadGroupSetsRequest": {
      "description": "The read group set search request.",
      "properties": {
        "datasetIds": {
          "description": "Restricts this query to read group sets within the given datasets. At least\none ID must be provided.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "description": "Only return read group sets for which a substring of the name matches this\nstring.",
          "type": "string"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 256. The maximum value is 1024.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReadGroupSetsResponse": {
      "description": "The read group set search response.",
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "readGroupSets": {
          "description": "The list of matching read group sets.",
          "items": {
            "$ref": "#/definitions/ReadGroupSet"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchReadsRequest": {
      "description": "The read search request.",
      "properties": {
        "end": {
          "description": "The end position of the range on the reference, 0-based exclusive. If\nspecified, `referenceName` must also be specified.",
          "format": "int64",
          "type": "string"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 256. The maximum value is 2048.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "readGroupIds": {
          "description": "The IDs of the read groups within which to search for reads. All specified\nread groups must belong to the same read group sets. Must specify one of\n`readGroupSetIds` or `readGroupIds`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "readGroupSetIds": {
          "description": "The IDs of the read groups sets within which to search for reads. All\nspecified read group sets must be aligned against a common set of reference\nsequences; this defines the genomic coordinates for the query. Must specify\none of `readGroupSetIds` or `readGroupIds`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "referenceName": {
          "description": "The reference sequence name, for example `chr1`, `1`, or `chrX`. If set to\n`*`, only unmapped reads are returned. If unspecified, all reads (mapped\nand unmapped) are returned.",
          "type": "string"
        },
        "start": {
          "description": "The start position of the range on the reference, 0-based inclusive. If\nspecified, `referenceName` must also be specified.",
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReadsResponse": {
      "description": "The read search response.",
      "properties": {
        "alignments": {
          "description": "The list of matching alignments sorted by mapped genomic coordinate,\nif any, ascending in position within the same reference. Unmapped reads,\nwhich have no position, are returned contiguously and are sorted in\nascending lexicographic order by fragment name.",
          "items": {
            "$ref": "#/definitions/Read"
          },
          "type": "array"
        },
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReferenceSetsRequest": {
      "properties": {
        "accessions": {
          "description": "If present, return reference sets for which a prefix of any of\nsourceAccessions\nmatch any of these strings. Accession numbers typically have a main number\nand a version, for example `NC_000001.11`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "assemblyId": {
          "description": "If present, return reference sets for which a substring of their\n`assemblyId` matches this string (case insensitive).",
          "type": "string"
        },
        "md5checksums": {
          "description": "If present, return reference sets for which the\nmd5checksum matches exactly.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 1024. The maximum value is 4096.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReferenceSetsResponse": {
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "referenceSets": {
          "description": "The matching references sets.",
          "items": {
            "$ref": "#/definitions/ReferenceSet"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchReferencesRequest": {
      "properties": {
        "accessions": {
          "description": "If present, return references for which a prefix of any of\nsourceAccessions match\nany of these strings. Accession numbers typically have a main number and a\nversion, for example `GCF_000001405.26`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "md5checksums": {
          "description": "If present, return references for which the\nmd5checksum matches exactly.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 1024. The maximum value is 4096.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "referenceSetId": {
          "description": "If present, return only references which belong to this reference set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchReferencesResponse": {
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "references": {
          "description": "The matching references.",
          "items": {
            "$ref": "#/definitions/Reference"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchVariantSetsRequest": {
      "description": "The search variant sets request.",
      "properties": {
        "datasetIds": {
          "description": "Exactly one dataset ID must be provided here. Only variant sets which\nbelong to this dataset will be returned.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pageSize": {
          "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 1024.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SearchVariantSetsResponse": {
      "description": "The search variant sets response.",
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "variantSets": {
          "description": "The variant sets belonging to the requested dataset.",
          "items": {
            "$ref": "#/definitions/VariantSet"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchVariantsRequest": {
      "description": "The variant search request.",
      "properties": {
        "callSetIds": {
          "description": "Only return variant calls which belong to call sets with these ids.\nLeaving this blank returns all variant calls. If a variant has no\ncalls belonging to any of these call sets, it won't be returned at all.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "end": {
          "description": "The end of the window, 0-based exclusive. If unspecified or 0, defaults to\nthe length of the reference.",
          "format": "int64",
          "type": "string"
        },
        "maxCalls": {
          "description": "The maximum number of calls to return in a single page. Note that this\nlimit may be exceeded in the event that a matching variant contains more\ncalls than the requested maximum. If unspecified, defaults to 5000. The\nmaximum value is 10000.",
          "format": "int32",
          "type": "integer"
        },
        "pageSize": {
          "description": "The maximum number of variants to return in a single page. If unspecified,\ndefaults to 5000. The maximum value is 10000.",
          "format": "int32",
          "type": "integer"
        },
        "pageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response.",
          "type": "string"
        },
        "referenceName": {
          "description": "Required. Only return variants in this reference sequence.",
          "type": "string"
        },
        "start": {
          "description": "The beginning of the window (0-based, inclusive) for which\noverlapping variants should be returned. If unspecified, defaults to 0.",
          "format": "int64",
          "type": "string"
        },
        "variantName": {
          "description": "Only return variants which have exactly this name.",
          "type": "string"
        },
        "variantSetIds": {
          "description": "At most one variant set ID must be provided. Only variants from this\nvariant set will be returned. If omitted, a call set id must be included in\nthe request.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SearchVariantsResponse": {
      "description": "The variant search response.",
      "properties": {
        "nextPageToken": {
          "description": "The continuation token, which is used to page through large result sets.\nProvide this value in a subsequent request to return the next page of\nresults. This field will be empty if there aren't any additional results.",
          "type": "string"
        },
        "variants": {
          "description": "The list of matching Variants.",
          "items": {
            "$ref": "#/definitions/Variant"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SetIamPolicyRequest": {
      "description": "Request message for `SetIamPolicy` method.",
      "properties": {
        "policy": {
          "$ref": "#/definitions/Policy",
          "description": "REQUIRED: The complete policy to be applied to the `resource`. The size of\nthe policy is limited to a few 10s of KB. An empty policy is a\nvalid policy but certain Cloud Platform services (such as Projects)\nmight reject them."
        }
      },
      "type": "object"
    },
    "Status": {
      "description": "The `Status` type defines a logical error model that is suitable for different\nprogramming environments, including REST APIs and RPC APIs. It is used by\n[gRPC](https://github.com/grpc). The error model is designed to be:\n\n- Simple to use and understand for most users\n- Flexible enough to meet unexpected needs\n\n# Overview\n\nThe `Status` message contains three pieces of data: error code, error message,\nand error details. The error code should be an enum value of\ngoogle.rpc.Code, but it may accept additional error codes if needed.  The\nerror message should be a developer-facing English message that helps\ndevelopers *understand* and *resolve* the error. If a localized user-facing\nerror message is needed, put the localized message in the error details or\nlocalize it in the client. The optional error details may contain arbitrary\ninformation about the error. There is a predefined set of error detail types\nin the package `google.rpc` which can be used for common error conditions.\n\n# Language mapping\n\nThe `Status` message is the logical representation of the error model, but it\nis not necessarily the actual wire format. When the `Status` message is\nexposed in different client libraries and different wire protocols, it can be\nmapped differently. For example, it will likely be mapped to some exceptions\nin Java, but more likely mapped to some error codes in C.\n\n# Other uses\n\nThe error model and the `Status` message can be used in a variety of\nenvironments, either with or without APIs, to provide a\nconsistent developer experience across different environments.\n\nExample uses of this error model include:\n\n- Partial errors. If a service needs to return partial errors to the client,\n    it may embed the `Status` in the normal response to indicate the partial\n    errors.\n\n- Workflow errors. A typical workflow has multiple steps. Each step may\n    have a `Status` message for error reporting purpose.\n\n- Batch operations. If a client uses batch request and batch response, the\n    `Status` message should be used directly inside batch response, one for\n    each error sub-response.\n\n- Asynchronous operations. If an API call embeds asynchronous operation\n    results in its response, the status of those operations should be\n    represented directly using the `Status` message.\n\n- Logging. If some API errors are stored in logs, the message `Status` could\n    be used directly after any stripping needed for security/privacy reasons.",
      "properties": {
        "code": {
          "description": "The status code, which should be an enum value of google.rpc.Code.",
          "format": "int32",
          "type": "integer"
        },
        "details": {
          "description": "A list of messages that carry the error details.  There will be a\ncommon set of message types for APIs to use.",
          "items": {
            "additionalProperties": {
              "description": "Properties of the object. Contains field @type with type URL."
            },
            "type": "object"
          },
          "type": "array"
        },
        "message": {
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\ngoogle.rpc.Status.details field, or localized by the client.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TestIamPermissionsRequest": {
      "description": "Request message for `TestIamPermissions` method.",
      "properties": {
        "permissions": {
          "description": "REQUIRED: The set of permissions to check for the 'resource'.\nPermissions with wildcards (such as '*' or 'storage.*') are not allowed.\nAllowed permissions are&#58;\n\n* `genomics.datasets.create`\n* `genomics.datasets.delete`\n* `genomics.datasets.get`\n* `genomics.datasets.list`\n* `genomics.datasets.update`\n* `genomics.datasets.getIamPolicy`\n* `genomics.datasets.setIamPolicy`",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TestIamPermissionsResponse": {
      "description": "Response message for `TestIamPermissions` method.",
      "properties": {
        "permissions": {
          "description": "A subset of `TestPermissionsRequest.permissions` that the caller is\nallowed.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "Transcript": {
      "description": "A transcript represents the assertion that a particular region of the\nreference genome may be transcribed as RNA.",
      "properties": {
        "codingSequence": {
          "$ref": "#/definitions/CodingSequence",
          "description": "The range of the coding sequence for this transcript, if any. To determine\nthe exact ranges of coding sequence, intersect this range with those of the\nexons, if any. If there are any\nexons, the\ncodingSequence must start\nand end within them.\n\nNote that in some cases, the reference genome will not exactly match the\nobserved mRNA transcript e.g. due to variance in the source genome from\nreference. In these cases,\nexon.frame will not necessarily\nmatch the expected reference reading frame and coding exon reference bases\ncannot necessarily be concatenated to produce the original transcript mRNA."
        },
        "exons": {
          "description": "The <a href=\"http://en.wikipedia.org/wiki/Exon\">exons</a> that compose\nthis transcript. This field should be unset for genomes where transcript\nsplicing does not occur, for example prokaryotes.\n\nIntrons are regions of the transcript that are not included in the\nspliced RNA product. Though not explicitly modeled here, intron ranges can\nbe deduced; all regions of this transcript that are not exons are introns.\n\nExonic sequences do not necessarily code for a translational product\n(amino acids). Only the regions of exons bounded by the\ncodingSequence correspond\nto coding DNA sequence.\n\nExons are ordered by start position and may not overlap.",
          "items": {
            "$ref": "#/definitions/Exon"
          },
          "type": "array"
        },
        "geneId": {
          "description": "The annotation ID of the gene from which this transcript is transcribed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "UndeleteDatasetRequest": {
      "properties": {},
      "type": "object"
    },
    "Variant": {
      "description": "A variant represents a change in DNA sequence relative to a reference\nsequence. For example, a variant could represent a SNP or an insertion.\nVariants belong to a variant set.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nEach of the calls on a variant represent a determination of genotype with\nrespect to that variant. For example, a call might assign probability of 0.32\nto the occurrence of a SNP named rs1234 in a sample named NA12345. A call\nbelongs to a call set, which contains related calls typically from one\nsample.",
      "properties": {
        "alternateBases": {
          "description": "The bases that appear instead of the reference bases.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "calls": {
          "description": "The variant calls for this particular variant. Each one represents the\ndetermination of genotype with respect to this variant.",
          "items": {
            "$ref": "#/definitions/VariantCall"
          },
          "type": "array"
        },
        "created": {
          "description": "The date this variant was created, in milliseconds from the epoch.",
          "format": "int64",
          "type": "string"
        },
        "end": {
          "description": "The end position (0-based) of this variant. This corresponds to the first\nbase after the last base in the reference allele. So, the length of\nthe reference allele is (end - start). This is useful for variants\nthat don't explicitly give alternate bases, for example large deletions.",
          "format": "int64",
          "type": "string"
        },
        "filter": {
          "description": "A list of filters (normally quality filters) this variant has failed.\n`PASS` indicates this variant has passed all filters.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "id": {
          "description": "The server-generated variant ID, unique across all variants.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional variant information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "names": {
          "description": "Names for the variant, for example a RefSNP ID.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "quality": {
          "description": "A measure of how likely this variant is to be real.\nA higher value is better.",
          "format": "double",
          "type": "number"
        },
        "referenceBases": {
          "description": "The reference bases for this variant. They start at the given\nposition.",
          "type": "string"
        },
        "referenceName": {
          "description": "The reference on which this variant occurs.\n(such as `chr20` or `X`)",
          "type": "string"
        },
        "start": {
          "description": "The position at which this variant occurs (0-based).\nThis corresponds to the first base of the string of reference bases.",
          "format": "int64",
          "type": "string"
        },
        "variantSetId": {
          "description": "The ID of the variant set this variant belongs to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "VariantAnnotation": {
      "properties": {
        "alternateBases": {
          "description": "The alternate allele for this variant. If multiple alternate alleles\nexist at this location, create a separate variant for each one, as they\nmay represent distinct conditions.",
          "type": "string"
        },
        "clinicalSignificance": {
          "description": "Describes the clinical significance of a variant.\nIt is adapted from the ClinVar controlled vocabulary for clinical\nsignificance described at:\nhttp://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/",
          "enum": [
            "CLINICAL_SIGNIFICANCE_UNSPECIFIED",
            "CLINICAL_SIGNIFICANCE_OTHER",
            "UNCERTAIN",
            "BENIGN",
            "LIKELY_BENIGN",
            "LIKELY_PATHOGENIC",
            "PATHOGENIC",
            "DRUG_RESPONSE",
            "HISTOCOMPATIBILITY",
            "CONFERS_SENSITIVITY",
            "RISK_FACTOR",
            "ASSOCIATION",
            "PROTECTIVE",
            "MULTIPLE_REPORTED"
          ],
          "type": "string"
        },
        "conditions": {
          "description": "The set of conditions associated with this variant.\nA condition describes the way a variant influences human health.",
          "items": {
            "$ref": "#/definitions/ClinicalCondition"
          },
          "type": "array"
        },
        "effect": {
          "description": "Effect of the variant on the coding sequence.",
          "enum": [
            "EFFECT_UNSPECIFIED",
            "EFFECT_OTHER",
            "FRAMESHIFT",
            "FRAME_PRESERVING_INDEL",
            "SYNONYMOUS_SNP",
            "NONSYNONYMOUS_SNP",
            "STOP_GAIN",
            "STOP_LOSS",
            "SPLICE_SITE_DISRUPTION"
          ],
          "type": "string"
        },
        "geneId": {
          "description": "Google annotation ID of the gene affected by this variant. This should\nbe provided when the variant is created.",
          "type": "string"
        },
        "transcriptIds": {
          "description": "Google annotation IDs of the transcripts affected by this variant. These\nshould be provided when the variant is created.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "type": {
          "description": "Type has been adapted from ClinVar's list of variant types.",
          "enum": [
            "TYPE_UNSPECIFIED",
            "TYPE_OTHER",
            "INSERTION",
            "DELETION",
            "SUBSTITUTION",
            "SNP",
            "STRUCTURAL",
            "CNV"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "VariantCall": {
      "description": "A call represents the determination of genotype with respect to a particular\nvariant. It may include associated information such as quality and phasing.\nFor example, a call might assign a probability of 0.32 to the occurrence of\na SNP named rs1234 in a call set with the name NA12345.",
      "properties": {
        "callSetId": {
          "description": "The ID of the call set this variant call belongs to.",
          "type": "string"
        },
        "callSetName": {
          "description": "The name of the call set this variant call belongs to.",
          "type": "string"
        },
        "genotype": {
          "description": "The genotype of this variant call. Each value represents either the value\nof the `referenceBases` field or a 1-based index into\n`alternateBases`. If a variant had a `referenceBases`\nvalue of `T` and an `alternateBases`\nvalue of `[\"A\", \"C\"]`, and the `genotype` was\n`[2, 1]`, that would mean the call\nrepresented the heterozygous value `CA` for this variant.\nIf the `genotype` was instead `[0, 1]`, the\nrepresented value would be `TA`. Ordering of the\ngenotype values is important if the `phaseset` is present.\nIf a genotype is not called (that is, a `.` is present in the\nGT string) -1 is returned.",
          "items": {
            "format": "int32",
            "type": "integer"
          },
          "type": "array"
        },
        "genotypeLikelihood": {
          "description": "The genotype likelihoods for this variant call. Each array entry\nrepresents how likely a specific genotype is for this call. The value\nordering is defined by the GL tag in the VCF spec.\nIf Phred-scaled genotype likelihood scores (PL) are available and\nlog10(P) genotype likelihood scores (GL) are not, PL scores are converted\nto GL scores.  If both are available, PL scores are stored in `info`.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "A map of additional variant call information. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "phaseset": {
          "description": "If this field is present, this variant call's genotype ordering implies\nthe phase of the bases and is consistent with any other variant calls in\nthe same reference sequence which have the same phaseset value.\nWhen importing data from VCF, if the genotype data was phased but no\nphase set was specified this field will be set to `*`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "VariantSet": {
      "description": "A variant set is a collection of call sets and variants. It contains summary\nstatistics of those contents. A variant set belongs to a dataset.\n\nFor more genomics resource definitions, see [Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "properties": {
        "datasetId": {
          "description": "The dataset to which this variant set belongs.",
          "type": "string"
        },
        "description": {
          "description": "A textual description of this variant set.",
          "type": "string"
        },
        "id": {
          "description": "The server-generated variant set ID, unique across all variant sets.",
          "type": "string"
        },
        "metadata": {
          "description": "The metadata associated with this variant set.",
          "items": {
            "$ref": "#/definitions/VariantSetMetadata"
          },
          "type": "array"
        },
        "name": {
          "description": "User-specified, mutable name.",
          "type": "string"
        },
        "referenceBounds": {
          "description": "A list of all references used by the variants in a variant set\nwith associated coordinate upper bounds for each one.",
          "items": {
            "$ref": "#/definitions/ReferenceBound"
          },
          "type": "array"
        },
        "referenceSetId": {
          "description": "The reference set to which the variant set is mapped. The reference set\ndescribes the alignment provenance of the variant set, while the\n`referenceBounds` describe the shape of the actual variant data. The\nreference set's reference names are a superset of those found in the\n`referenceBounds`.\n\nFor example, given a variant set that is mapped to the GRCh38 reference set\nand contains a single variant on reference 'X', `referenceBounds` would\ncontain only an entry for 'X', while the associated reference set\nenumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "VariantSetMetadata": {
      "description": "Metadata describes a single piece of variant call metadata.\nThese data include a top level key and either a single value string (value)\nor a list of key-value pairs (info.)\nValue and info are mutually exclusive.",
      "properties": {
        "description": {
          "description": "A textual description of this metadata.",
          "type": "string"
        },
        "id": {
          "description": "User-provided ID field, not enforced by this API.\nTwo or more pieces of structured metadata with identical\nid and key fields are considered equivalent.",
          "type": "string"
        },
        "info": {
          "additionalProperties": {
            "items": {},
            "type": "array"
          },
          "description": "Remaining structured metadata key-value pairs. This must be of the form\nmap<string, string[]> (string key mapping to a list of string values).",
          "type": "object"
        },
        "key": {
          "description": "The top-level key.",
          "type": "string"
        },
        "number": {
          "description": "The number of values that can be included in a field described by this\nmetadata.",
          "type": "string"
        },
        "type": {
          "description": "The type of data. Possible types include: Integer, Float,\nFlag, Character, and String.",
          "enum": [
            "TYPE_UNSPECIFIED",
            "INTEGER",
            "FLOAT",
            "FLAG",
            "CHARACTER",
            "STRING"
          ],
          "type": "string"
        },
        "value": {
          "description": "The value field for simple metadata",
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "actions": [
    {
      "id": "annotations.create",
      "title": "annotations.create",
      "description": "Creates a new annotation. Caller must have WRITE permission\nfor the associated annotation set.\n\nThe following fields are required:\n\n* annotationSetId\n* referenceName or\n  referenceId\n\n### Transcripts\n\nFor annotations of type TRANSCRIPT, the following fields of\ntranscript must be provided:\n\n* exons.start\n* exons.end\n\nAll other fields may be optionally specified, unless documented as being\nserver-generated (for example, the `id` field). The annotated\nrange must be no longer than 100Mbp (mega base pairs). See the\nAnnotation resource\nfor additional restrictions on each field.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/Annotation"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Annotation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotations.search",
      "title": "annotations.search",
      "description": "Searches for annotations that match the given criteria. Results are\nordered by genomic coordinate (by reference sequence, then position).\nAnnotations with equivalent genomic coordinates are returned in an\nunspecified order. This order is consistent, such that two queries for the\nsame content (regardless of page size) yield annotations in the same order\nacross their respective streams of paginated responses. Caller must have\nREAD permission for the queried annotation sets.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchAnnotationsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchAnnotationsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotations.delete",
      "title": "annotations.delete",
      "description": "Deletes an annotation. Caller must have WRITE permission for\nthe associated annotation set.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationId": {
            "type": "string",
            "description": "The ID of the annotation to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotations.get",
      "title": "annotations.get",
      "description": "Gets an annotation. Caller must have READ permission\nfor the associated annotation set.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationId": {
            "type": "string",
            "description": "The ID of the annotation to be retrieved."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Annotation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotations.update",
      "title": "annotations.update",
      "description": "Updates an annotation. Caller must have\nWRITE permission for the associated dataset.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationId": {
            "type": "string",
            "description": "The ID of the annotation to be updated."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. Mutable fields are\nname,\nvariant,\ntranscript, and\ninfo. If unspecified, all mutable\nfields will be updated."
          },
          "body": {
            "$ref": "#/definitions/Annotation"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Annotation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotations.batchCreate",
      "title": "annotations.batchCreate",
      "description": "Creates one or more new annotations atomically. All annotations must\nbelong to the same annotation set. Caller must have WRITE\npermission for this annotation set. For optimal performance, batch\npositionally adjacent annotations together.\n\nIf the request has a systemic issue, such as an attempt to write to\nan inaccessible annotation set, the entire RPC will fail accordingly. For\nlesser data issues, when possible an error will be isolated to the\ncorresponding batch entry in the response; the remaining well formed\nannotations will be created normally.\n\nFor details on the requirements for each individual annotation resource,\nsee\nCreateAnnotation.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/BatchCreateAnnotationsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BatchCreateAnnotationsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotationsets.create",
      "title": "annotationsets.create",
      "description": "Creates a new annotation set. Caller must have WRITE permission for the\nassociated dataset.\n\nThe following fields are required:\n\n  * datasetId\n  * referenceSetId\n\nAll other fields may be optionally specified, unless documented as being\nserver-generated (for example, the `id` field).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/AnnotationSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/AnnotationSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotationsets.search",
      "title": "annotationsets.search",
      "description": "Searches for annotation sets that match the given criteria. Annotation sets\nare returned in an unspecified order. This order is consistent, such that\ntwo queries for the same content (regardless of page size) yield annotation\nsets in the same order across their respective streams of paginated\nresponses. Caller must have READ permission for the queried datasets.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchAnnotationSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchAnnotationSetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotationsets.delete",
      "title": "annotationsets.delete",
      "description": "Deletes an annotation set. Caller must have WRITE permission\nfor the associated annotation set.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationSetId": {
            "type": "string",
            "description": "The ID of the annotation set to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotationsets.get",
      "title": "annotationsets.get",
      "description": "Gets an annotation set. Caller must have READ permission for\nthe associated dataset.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationSetId": {
            "type": "string",
            "description": "The ID of the annotation set to be retrieved."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/AnnotationSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "annotationsets.update",
      "title": "annotationsets.update",
      "description": "Updates an annotation set. The update must respect all mutability\nrestrictions and other invariants described on the annotation set resource.\nCaller must have WRITE permission for the associated dataset.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "annotationSetId": {
            "type": "string",
            "description": "The ID of the annotation set to be updated."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. Mutable fields are\nname,\nsource_uri, and\ninfo. If unspecified, all\nmutable fields will be updated."
          },
          "body": {
            "$ref": "#/definitions/AnnotationSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/AnnotationSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "callsets.create",
      "title": "callsets.create",
      "description": "Creates a new call set.\n\nFor the definitions of call sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/CallSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CallSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "callsets.search",
      "title": "callsets.search",
      "description": "Gets a list of call sets matching the criteria.\n\nFor the definitions of call sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchCallSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchCallSetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "callsets.delete",
      "title": "callsets.delete",
      "description": "Deletes a call set.\n\nFor the definitions of call sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "callSetId": {
            "type": "string",
            "description": "The ID of the call set to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "callsets.get",
      "title": "callsets.get",
      "description": "Gets a call set by ID.\n\nFor the definitions of call sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "callSetId": {
            "type": "string",
            "description": "The ID of the call set."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CallSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "callsets.patch",
      "title": "callsets.patch",
      "description": "Updates a call set.\n\nFor the definitions of call sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThis method supports patch semantics.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "callSetId": {
            "type": "string",
            "description": "The ID of the call set to be updated."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. At this time, the only\nmutable field is name. The only\nacceptable value is \"name\". If unspecified, all mutable fields will be\nupdated."
          },
          "body": {
            "$ref": "#/definitions/CallSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CallSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.list",
      "title": "datasets.list",
      "description": "Lists datasets within a project.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "pageToken": {
            "type": "string",
            "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response."
          },
          "pageSize": {
            "type": "integer",
            "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 50. The maximum value is 1024."
          },
          "projectId": {
            "type": "string",
            "description": "Required. The Google Cloud project ID to list datasets for."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ListDatasetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.create",
      "title": "datasets.create",
      "description": "Creates a new dataset.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/Dataset"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Dataset"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.delete",
      "title": "datasets.delete",
      "description": "Deletes a dataset and all of its contents (all read group sets,\nreference sets, variant sets, call sets, annotation sets, etc.)\nThis is reversible (up to one week after the deletion) via\nthe\ndatasets.undelete\noperation.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.get",
      "title": "datasets.get",
      "description": "Gets a dataset by ID.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Dataset"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.patch",
      "title": "datasets.patch",
      "description": "Updates a dataset.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThis method supports patch semantics.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset to be updated."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. At this time, the only\nmutable field is name. The only\nacceptable value is \"name\". If unspecified, all mutable fields will be\nupdated."
          },
          "body": {
            "$ref": "#/definitions/Dataset"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Dataset"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.undelete",
      "title": "datasets.undelete",
      "description": "Undeletes a dataset by restoring a dataset which was deleted via this API.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThis operation is only possible for a week after the deletion occurred.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "datasetId": {
            "type": "string",
            "description": "The ID of the dataset to be undeleted."
          },
          "body": {
            "$ref": "#/definitions/UndeleteDatasetRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Dataset"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.search",
      "title": "readgroupsets.search",
      "description": "Searches for read group sets matching the criteria.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchReadGroupSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L135).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchReadGroupSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchReadGroupSetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.delete",
      "title": "readgroupsets.delete",
      "description": "Deletes a read group set.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "readGroupSetId": {
            "type": "string",
            "description": "The ID of the read group set to be deleted. The caller must have WRITE\npermissions to the dataset associated with this read group set."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.get",
      "title": "readgroupsets.get",
      "description": "Gets a read group set by ID.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "readGroupSetId": {
            "type": "string",
            "description": "The ID of the read group set."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ReadGroupSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.patch",
      "title": "readgroupsets.patch",
      "description": "Updates a read group set.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThis method supports patch semantics.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "readGroupSetId": {
            "type": "string",
            "description": "The ID of the read group set to be updated. The caller must have WRITE\npermissions to the dataset associated with this read group set."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. Supported fields:\n\n* name.\n* referenceSetId.\n\nLeaving `updateMask` unset is equivalent to specifying all mutable\nfields."
          },
          "body": {
            "$ref": "#/definitions/ReadGroupSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ReadGroupSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.coveragebuckets.list",
      "title": "readgroupsets.coveragebuckets.list",
      "description": "Lists fixed width coverage buckets for a read group set, each of which\ncorrespond to a range of a reference sequence. Each bucket summarizes\ncoverage information across its corresponding genomic range.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nCoverage is defined as the number of reads which are aligned to a given\nbase in the reference sequence. Coverage buckets are available at several\nprecomputed bucket widths, enabling retrieval of various coverage 'zoom\nlevels'. The caller must have READ permissions for the target read group\nset.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "readGroupSetId": {
            "type": "string",
            "description": "Required. The ID of the read group set over which coverage is requested."
          },
          "end": {
            "type": "string",
            "description": "The end position of the range on the reference, 0-based exclusive. If\nspecified, `referenceName` must also be specified. If unset or 0, defaults\nto the length of the reference."
          },
          "pageToken": {
            "type": "string",
            "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response."
          },
          "pageSize": {
            "type": "integer",
            "description": "The maximum number of results to return in a single page. If unspecified,\ndefaults to 1024. The maximum value is 2048."
          },
          "start": {
            "type": "string",
            "description": "The start position of the range on the reference, 0-based inclusive. If\nspecified, `referenceName` must also be specified. Defaults to 0."
          },
          "targetBucketWidth": {
            "type": "string",
            "description": "The desired width of each reported coverage bucket in base pairs. This\nwill be rounded down to the nearest precomputed bucket width; the value\nof which is returned as `bucketWidth` in the response. Defaults\nto infinity (each bucket spans an entire reference sequence) or the length\nof the target range, if specified. The smallest precomputed\n`bucketWidth` is currently 2048 base pairs; this is subject to\nchange."
          },
          "referenceName": {
            "type": "string",
            "description": "The name of the reference to query, within the reference set associated\nwith this query. Optional."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ListCoverageBucketsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.export",
      "title": "readgroupsets.export",
      "description": "Exports a read group set to a BAM file in Google Cloud Storage.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nNote that currently there may be some differences between exported BAM\nfiles and the original BAM file at the time of import. See\nImportReadGroupSets\nfor caveats.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "readGroupSetId": {
            "type": "string",
            "description": "Required. The ID of the read group set to export. The caller must have\nREAD access to this read group set."
          },
          "body": {
            "$ref": "#/definitions/ExportReadGroupSetRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Operation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "readgroupsets.import",
      "title": "readgroupsets.import",
      "description": "Creates read group sets by asynchronously importing the provided\ninformation.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThe caller must have WRITE permissions to the dataset.\n\n## Notes on [BAM](https://samtools.github.io/hts-specs/SAMv1.pdf) import\n\n- Tags will be converted to strings - tag types are not preserved\n- Comments (`@CO`) in the input file header will not be preserved\n- Original header order of references (`@SQ`) will not be preserved\n- Any reverse stranded unmapped reads will be reverse complemented, and\ntheir qualities (also the \"BQ\" and \"OQ\" tags, if any) will be reversed\n- Unmapped reads will be stripped of positional information (reference name\nand position)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/ImportReadGroupSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Operation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "reads.search",
      "title": "reads.search",
      "description": "Gets a list of reads for one or more read group sets.\n\nFor the definitions of read group sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nReads search operates over a genomic coordinate space of reference sequence\n& position defined over the reference sequences to which the requested\nread group sets are aligned.\n\nIf a target positional range is specified, search returns all reads whose\nalignment to the reference genome overlap the range. A query which\nspecifies only read group set IDs yields all reads in those read group\nsets, including unmapped reads.\n\nAll reads returned (including reads on subsequent pages) are ordered by\ngenomic coordinate (by reference sequence, then position). Reads with\nequivalent genomic coordinates are returned in an unspecified order. This\norder is consistent, such that two queries for the same content (regardless\nof page size) yield reads in the same order across their respective streams\nof paginated responses.\n\nImplements\n[GlobalAllianceApi.searchReads](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L85).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchReadsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchReadsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "references.search",
      "title": "references.search",
      "description": "Searches for references which match the given criteria.\n\nFor the definitions of references and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchReferencesRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchReferencesResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "references.get",
      "title": "references.get",
      "description": "Gets a reference.\n\nFor the definitions of references and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "referenceId": {
            "type": "string",
            "description": "The ID of the reference."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Reference"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "references.bases.list",
      "title": "references.bases.list",
      "description": "Lists the bases in a reference, optionally restricted to a range.\n\nFor the definitions of references and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "referenceId": {
            "type": "string",
            "description": "The ID of the reference."
          },
          "end": {
            "type": "string",
            "description": "The end position (0-based, exclusive) of this query. Defaults to the length\nof this reference."
          },
          "pageToken": {
            "type": "string",
            "description": "The continuation token, which is used to page through large result sets.\nTo get the next page of results, set this parameter to the value of\n`nextPageToken` from the previous response."
          },
          "pageSize": {
            "type": "integer",
            "description": "The maximum number of bases to return in a single page. If unspecified,\ndefaults to 200Kbp (kilo base pairs). The maximum value is 10Mbp (mega base\npairs)."
          },
          "start": {
            "type": "string",
            "description": "The start position (0-based) of this query. Defaults to 0."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ListBasesResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "referencesets.search",
      "title": "referencesets.search",
      "description": "Searches for reference sets which match the given criteria.\n\nFor the definitions of references and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchReferenceSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchReferenceSetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "referencesets.get",
      "title": "referencesets.get",
      "description": "Gets a reference set.\n\nFor the definitions of references and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "referenceSetId": {
            "type": "string",
            "description": "The ID of the reference set."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ReferenceSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.create",
      "title": "variants.create",
      "description": "Creates a new variant.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/Variant"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Variant"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.search",
      "title": "variants.search",
      "description": "Gets a list of variants matching the criteria.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchVariantsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchVariantsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.delete",
      "title": "variants.delete",
      "description": "Deletes a variant.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantId": {
            "type": "string",
            "description": "The ID of the variant to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.get",
      "title": "variants.get",
      "description": "Gets a variant by ID.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantId": {
            "type": "string",
            "description": "The ID of the variant."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Variant"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.patch",
      "title": "variants.patch",
      "description": "Updates a variant.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThis method supports patch semantics. Returns the modified variant without\nits calls.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantId": {
            "type": "string",
            "description": "The ID of the variant to be updated."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. At this time, mutable\nfields are names and\ninfo. Acceptable values are \"names\" and\n\"info\". If unspecified, all mutable fields will be updated."
          },
          "body": {
            "$ref": "#/definitions/Variant"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Variant"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.import",
      "title": "variants.import",
      "description": "Creates variant data by asynchronously importing the provided information.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThe variants for import will be merged with any existing variant that\nmatches its reference sequence, start, end, reference bases, and\nalternative bases. If no such variant exists, a new one will be created.\n\nWhen variants are merged, the call information from the new variant\nis added to the existing variant, and Variant info fields are merged\nas specified in\ninfoMergeConfig.\nAs a special case, for single-sample VCF files, QUAL and FILTER fields will\nbe moved to the call level; these are sometimes interpreted in a\ncall-specific context.\nImported VCF headers are appended to the metadata already in a variant set.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/ImportVariantsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Operation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variants.merge",
      "title": "variants.merge",
      "description": "Merges the given variants with existing variants.\n\nFor the definitions of variants and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nEach variant will be\nmerged with an existing variant that matches its reference sequence,\nstart, end, reference bases, and alternative bases. If no such variant\nexists, a new one will be created.\n\nWhen variants are merged, the call information from the new variant\nis added to the existing variant. Variant info fields are merged as\nspecified in the\ninfoMergeConfig\nfield of the MergeVariantsRequest.\n\nPlease exercise caution when using this method!  It is easy to introduce\nmistakes in existing variants and difficult to back out of them.  For\nexample,\nsuppose you were trying to merge a new variant with an existing one and\nboth\nvariants contain calls that belong to callsets with the same callset ID.\n\n    // Existing variant - irrelevant fields trimmed for clarity\n    {\n        \"variantSetId\": \"10473108253681171589\",\n        \"referenceName\": \"1\",\n        \"start\": \"10582\",\n        \"referenceBases\": \"G\",\n        \"alternateBases\": [\n            \"A\"\n        ],\n        \"calls\": [\n            {\n                \"callSetId\": \"10473108253681171589-0\",\n                \"callSetName\": \"CALLSET0\",\n                \"genotype\": [\n                    0,\n                    1\n                ],\n            }\n        ]\n    }\n\n    // New variant with conflicting call information\n    {\n        \"variantSetId\": \"10473108253681171589\",\n        \"referenceName\": \"1\",\n        \"start\": \"10582\",\n        \"referenceBases\": \"G\",\n        \"alternateBases\": [\n            \"A\"\n        ],\n        \"calls\": [\n            {\n                \"callSetId\": \"10473108253681171589-0\",\n                \"callSetName\": \"CALLSET0\",\n                \"genotype\": [\n                    1,\n                    1\n                ],\n            }\n        ]\n    }\n\nThe resulting merged variant would overwrite the existing calls with those\nfrom the new variant:\n\n    {\n        \"variantSetId\": \"10473108253681171589\",\n        \"referenceName\": \"1\",\n        \"start\": \"10582\",\n        \"referenceBases\": \"G\",\n        \"alternateBases\": [\n            \"A\"\n        ],\n        \"calls\": [\n            {\n                \"callSetId\": \"10473108253681171589-0\",\n                \"callSetName\": \"CALLSET0\",\n                \"genotype\": [\n                    1,\n                    1\n                ],\n            }\n        ]\n    }\n\nThis may be the desired outcome, but it is up to the user to determine if\nif that is indeed the case.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/MergeVariantsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.create",
      "title": "variantsets.create",
      "description": "Creates a new variant set.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nThe provided variant set must have a valid `datasetId` set - all other\nfields are optional. Note that the `id` field will be ignored, as this is\nassigned by the server.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/VariantSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/VariantSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.search",
      "title": "variantsets.search",
      "description": "Returns a list of all variant sets matching search criteria.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nImplements\n[GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "body": {
            "$ref": "#/definitions/SearchVariantSetsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/SearchVariantSetsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.delete",
      "title": "variantsets.delete",
      "description": "Deletes a variant set including all variants, call sets, and calls within.\nThis is not reversible.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantSetId": {
            "type": "string",
            "description": "The ID of the variant set to be deleted."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.get",
      "title": "variantsets.get",
      "description": "Gets a variant set by ID.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantSetId": {
            "type": "string",
            "description": "Required. The ID of the variant set."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/VariantSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.patch",
      "title": "variantsets.patch",
      "description": "Updates a variant set using patch semantics.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantSetId": {
            "type": "string",
            "description": "The ID of the variant to be updated (must already exist)."
          },
          "updateMask": {
            "type": "string",
            "description": "An optional mask specifying which fields to update. Supported fields:\n\n* metadata.\n* name.\n* description.\n\nLeaving `updateMask` unset is equivalent to specifying all mutable\nfields."
          },
          "body": {
            "$ref": "#/definitions/VariantSet"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/VariantSet"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "variantsets.export",
      "title": "variantsets.export",
      "description": "Exports variant set data to an external destination.\n\nFor the definitions of variant sets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "variantSetId": {
            "type": "string",
            "description": "Required. The ID of the variant set that contains variant data which\nshould be exported. The caller must have READ access to this variant set."
          },
          "body": {
            "$ref": "#/definitions/ExportVariantSetRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Operation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "operations.get",
      "title": "operations.get",
      "description": "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the operation resource."
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Operation"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "operations.cancel",
      "title": "operations.cancel",
      "description": "Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. Clients may use Operations.GetOperation or Operations.ListOperations to check whether the cancellation succeeded or the operation completed despite cancellation.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the operation resource to be cancelled."
          },
          "body": {
            "$ref": "#/definitions/CancelOperationRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Empty"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.getIamPolicy",
      "title": "datasets.getIamPolicy",
      "description": "Gets the access control policy for the dataset. This is empty if the\npolicy or resource does not exist.\n\nSee <a href=\"/iam/docs/managing-policies#getting_a_policy\">Getting a\nPolicy</a> for more information.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "string",
            "description": "REQUIRED: The resource for which policy is being specified. Format is\n`datasets/<dataset ID>`."
          },
          "body": {
            "$ref": "#/definitions/GetIamPolicyRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Policy"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.setIamPolicy",
      "title": "datasets.setIamPolicy",
      "description": "Sets the access control policy on the specified dataset. Replaces any\nexisting policy.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)\n\nSee <a href=\"/iam/docs/managing-policies#setting_a_policy\">Setting a\nPolicy</a> for more information.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "string",
            "description": "REQUIRED: The resource for which policy is being specified. Format is\n`datasets/<dataset ID>`."
          },
          "body": {
            "$ref": "#/definitions/SetIamPolicyRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Policy"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    },
    {
      "id": "datasets.testIamPermissions",
      "title": "datasets.testIamPermissions",
      "description": "Returns permissions that a caller has on the specified resource.\nSee <a href=\"/iam/docs/managing-policies#testing_permissions\">Testing\nPermissions</a> for more information.\n\nFor the definitions of datasets and other genomics resources, see\n[Fundamentals of Google\nGenomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "string",
            "description": "REQUIRED: The resource for which policy is being specified. Format is\n`datasets/<dataset ID>`."
          },
          "body": {
            "$ref": "#/definitions/TestIamPermissionsRequest"
          },
          "$.xgafv": {
            "type": "string",
            "description": "V1 error format.",
            "enum": [
              "1",
              "2"
            ]
          },
          "callback": {
            "type": "string",
            "description": "JSONP"
          },
          "alt": {
            "type": "string",
            "description": "Data format for response.",
            "enum": [
              "json",
              "media",
              "proto"
            ]
          },
          "access_token": {
            "type": "string",
            "description": "OAuth access token."
          },
          "key": {
            "type": "string",
            "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
          },
          "quotaUser": {
            "type": "string",
            "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
          },
          "pp": {
            "type": "boolean",
            "description": "Pretty-print response."
          },
          "oauth_token": {
            "type": "string",
            "description": "OAuth 2.0 token for the current user."
          },
          "bearer_token": {
            "type": "string",
            "description": "OAuth bearer token."
          },
          "upload_protocol": {
            "type": "string",
            "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
          },
          "prettyPrint": {
            "type": "boolean",
            "description": "Returns response with indentations and line breaks."
          },
          "fields": {
            "type": "string",
            "description": "Selector specifying which fields to include in a partial response."
          },
          "uploadType": {
            "type": "string",
            "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TestIamPermissionsResponse"
      },
      "security": {
        "google_genomics": {
          "integration": "google_genomics"
        }
      }
    }
  ]
}