{
  "swagger": "2.0",
  "schemes": [
    "https"
  ],
  "host": "api.turbinelabs.io",
  "basePath": "/v1.0",
  "info": {
    "contact": {
      "x-twitter": "GoTurbine"
    },
    "description": "The Turbine Labs API provides CRUD operations for core object types, and is\nmostly RESTy. The easiest way to interact with the API is with\n[tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html).\nIf you want to make direct HTTP calls, however, you can obtain an access\ntoken using tbnctl, and then pass it in the Authorization header,\nprefixed by `Token `:\n```console\ncurl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster\n```\n",
    "title": "Turbine Labs API",
    "version": "1.0",
    "x-apisguru-categories": [
      "cloud"
    ],
    "x-logo": {
      "url": "https://api.apis.guru/v2/cache/logo/https_twitter.com_GoTurbine_profile_image.jpeg"
    },
    "x-origin": [
      {
        "format": "swagger",
        "url": "https://raw.githubusercontent.com/turbinelabs/api/master/swagger.yml",
        "version": "2.0"
      }
    ],
    "x-preferred": true,
    "x-providerName": "turbinelabs.io",
    "x-datafire": {
      "name": "turbinelabs",
      "type": "openapi"
    }
  },
  "produces": [
    "application/json"
  ],
  "securityDefinitions": {
    "api_key": {
      "in": "header",
      "name": "Authorization",
      "type": "apiKey"
    }
  },
  "security": [
    {
      "api_key": []
    }
  ],
  "tags": [
    {
      "description": "A logical deployment of services, which typically maps to a datacenter, availability zone, or compute cluster.",
      "name": "Zone"
    },
    {
      "description": "A configuration that can be applied to one or more running Proxies serving one or more Domains.",
      "name": "Proxy"
    },
    {
      "description": "An interface and port a Proxy will listen on",
      "name": "Listener"
    },
    {
      "description": "A served hostname and port.",
      "name": "Domain"
    },
    {
      "description": "A served path within a Domain.",
      "name": "Route"
    },
    {
      "description": "A collection of rules specifying how a request should be mapped to an instance within a cluster. These may be shared between multiple Routes.",
      "name": "Shared Rules"
    },
    {
      "description": "A collection of Instances, homogeneous in their purpose, heterogeneous in their metadata.",
      "name": "Cluster"
    },
    {
      "description": "A collection of events that have occurred in your infrastructure. This includes changes detected by the deployed collectors (new Clusters or Cluster instances) as well as routing changes through the UI or API.",
      "name": "Audit Log"
    }
  ],
  "paths": {
    "/admin/user/self": {
      "get": {
        "description": "Request the user object for an authorized requesting account.",
        "responses": {
          "200": {
            "description": "The authorized user.",
            "schema": {
              "$ref": "#/definitions/User"
            }
          },
          "default": {
            "description": "Unexpected error.",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Returns the user object for the account authorized and making this request.",
        "tags": [
          "User Management"
        ],
        "operationId": "admin.user.self.get"
      }
    },
    "/admin/user/self/access_token/{access-token-key}": {
      "delete": {
        "parameters": [
          {
            "description": "the key of the Access Token that should be deleted",
            "in": "path",
            "name": "access-token-key",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "the current checksum of the user to be modified",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "An empty result if the API key deletion was successful."
          },
          "default": {
            "description": "An error; may be unexpected or validation error if the last API was removed.",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Delete the specified access token.",
        "tags": [
          "User Management"
        ],
        "operationId": "admin.user.self.access_token.access_token_key.delete"
      }
    },
    "/admin/user/self/access_tokens": {
      "get": {
        "responses": {
          "200": {
            "description": "A list of Access Tokens defined for the authenticated user.",
            "schema": {
              "$ref": "#/definitions/MultiAccessTokens"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Lists Access Tokens that are configured for the authenticated user.",
        "tags": [
          "User Management"
        ],
        "operationId": "admin.user.self.access_tokens.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A short string (<255 characters) describing the expected use of the token.",
            "in": "body",
            "name": "description",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AccessTokenDescription"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The new Access Token that was created.",
            "schema": {
              "$ref": "#/definitions/AccessToken"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Creates a new Access Token and associates it with the authenticated user.",
        "tags": [
          "User Management"
        ],
        "operationId": "admin.user.self.access_tokens.post"
      }
    },
    "/changelog/adhoc": {
      "get": {
        "description": "Perform an adhoc query against the change log for your org. The filter is a JSON encoded FilterSum as defined in this file.",
        "parameters": [
          {
            "description": "Encoded FilterSums representing the query you would like to execute. See object definition for details.",
            "in": "query",
            "name": "filter",
            "type": "string",
            "x-ref-encoded-object": "#/definitions/FilterSums"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes that meet the provided filter.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "Allows an arbitrary filter to be specified and applied to the org\\'s change log.",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.adhoc.get"
      }
    },
    "/changelog/cluster-graph/{clusterKey}": {
      "get": {
        "description": "Gets all changes to a cluster.\n",
        "parameters": [
          {
            "description": "the cluster key to see an audit log for",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "The beginning of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "number"
          },
          {
            "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "number"
          },
          {
            "description": "Determines how many ChangeDescription object should be returned to\nthe calling code.\n",
            "format": "int64",
            "in": "query",
            "name": "max_results",
            "required": false,
            "type": "number"
          },
          {
            "description": "When paginating a Changelog request start on the entry that comes\nimmediately before or after this ID (as determined by the direction\nargument).\n",
            "in": "query",
            "name": "ref_id",
            "required": false,
            "type": "string"
          },
          {
            "description": "If set to \"before\" then changes will be returned that occurred before\nreference ID. If \"after\" then changes will be returned that have\noccurred since the reference ID.\n",
            "enum": [
              "before",
              "after"
            ],
            "in": "query",
            "name": "direction",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes occurring during the requested window.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get changes related to the indicated cluster",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.cluster_graph.clusterKey.get"
      }
    },
    "/changelog/domain-graph/{domainKey}": {
      "get": {
        "description": "Gets all changes to a domain, the proxies that front the specified domain,\nroutes within that domain, the shared rules of each route, the clusters\nconnected via route or shared rules.\n",
        "parameters": [
          {
            "description": "the domain key to see an audit log for",
            "in": "path",
            "name": "domainKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "The beginning of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "number"
          },
          {
            "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "number"
          },
          {
            "description": "Determines how many ChangeDescription object should be returned to\nthe calling code.\n",
            "format": "int64",
            "in": "query",
            "name": "max_results",
            "required": false,
            "type": "number"
          },
          {
            "description": "When paginating a Changelog request start on the entry that comes\nimmediately before or after this ID (as determined by the direction\nargument).\n",
            "in": "query",
            "name": "ref_id",
            "required": false,
            "type": "string"
          },
          {
            "description": "If set to \"before\" then changes will be returned that occurred before\nreference ID. If \"after\" then changes will be returned that have\noccurred since the reference ID.\n",
            "enum": [
              "before",
              "after"
            ],
            "in": "query",
            "name": "direction",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes occurring during the requested window.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get changes related to the indicated domain",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.domain_graph.domainKey.get"
      }
    },
    "/changelog/route-graph/{routeKey}": {
      "get": {
        "description": "Gets all changes to a route, the domains associated with it, the shared\nrules it references, and the clusters connected to it.\n",
        "parameters": [
          {
            "description": "the route key to see an audit log for",
            "in": "path",
            "name": "routeKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "The beginning of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "number"
          },
          {
            "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "number"
          },
          {
            "description": "Determines how many ChangeDescription object should be returned to\nthe calling code.\n",
            "format": "int64",
            "in": "query",
            "name": "max_results",
            "required": false,
            "type": "number"
          },
          {
            "description": "When paginating a Changelog request start on the entry that comes\nimmediately before or after this ID (as determined by the direction\nargument).\n",
            "in": "query",
            "name": "ref_id",
            "required": false,
            "type": "string"
          },
          {
            "description": "If set to \"before\" then changes will be returned that occurred before\nreference ID. If \"after\" then changes will be returned that have\noccurred since the reference ID.\n",
            "enum": [
              "before",
              "after"
            ],
            "in": "query",
            "name": "direction",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes occurring during the requested window.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get changes related to the indicated route",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.route_graph.routeKey.get"
      }
    },
    "/changelog/shared-rules-graph/{sharedRulesKey}": {
      "get": {
        "description": "Gets all changes associated with set of Shared Rules; the domains using\nit and the clusters referenced by it.\n",
        "parameters": [
          {
            "description": "the shared rules key to see an audit log for",
            "in": "path",
            "name": "sharedRulesKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "The beginning of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "number"
          },
          {
            "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "number"
          },
          {
            "description": "Determines how many ChangeDescription object should be returned to\nthe calling code.\n",
            "format": "int64",
            "in": "query",
            "name": "max_results",
            "required": false,
            "type": "number"
          },
          {
            "description": "When paginating a Changelog request start on the entry that comes\nimmediately before or after this ID (as determined by the direction\nargument).\n",
            "in": "query",
            "name": "ref_id",
            "required": false,
            "type": "string"
          },
          {
            "description": "If set to \"before\" then changes will be returned that occurred before\nreference ID. If \"after\" then changes will be returned that have\noccurred since the reference ID.\n",
            "enum": [
              "before",
              "after"
            ],
            "in": "query",
            "name": "direction",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes occurring during the requested window.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get changes related to the indicated SharedRules",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.shared_rules_graph.sharedRulesKey.get"
      }
    },
    "/changelog/zone/{zoneKey}": {
      "get": {
        "description": "Retrieve all changes in the specified zone.",
        "parameters": [
          {
            "description": "the zone key to see an audit log for",
            "in": "path",
            "name": "zoneKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "The beginning of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "number"
          },
          {
            "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
            "format": "int64",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "number"
          },
          {
            "description": "Determines how many ChangeDescription object should be returned to\nthe calling code.\n",
            "format": "int64",
            "in": "query",
            "name": "max_results",
            "required": false,
            "type": "number"
          },
          {
            "description": "When paginating a Changelog request start on the entry that comes\nimmediately before or after this ID (as determined by the direction\nargument).\n",
            "in": "query",
            "name": "ref_id",
            "required": false,
            "type": "string"
          },
          {
            "description": "If set to \"before\" then changes will be returned that occurred before\nreference ID. If \"after\" then changes will be returned that have\noccurred since the reference ID.\n",
            "enum": [
              "before",
              "after"
            ],
            "in": "query",
            "name": "direction",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of changes occurring during the requested window.",
            "schema": {
              "$ref": "#/definitions/PaginatedChangeDescriptions"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get changes in a specified zone",
        "tags": [
          "Audit Log"
        ],
        "operationId": "changelog.zone.zoneKey.get"
      }
    },
    "/cluster": {
      "get": {
        "description": "Get a list of clusters",
        "parameters": [
          {
            "description": "A JSON encoded array of ClusterFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any ClusterFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of clusters",
            "schema": {
              "$ref": "#/definitions/MultiClusterResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get clusters",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new cluster",
        "parameters": [
          {
            "description": "the cluster to create",
            "in": "body",
            "name": "cluster",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created cluster",
            "schema": {
              "$ref": "#/definitions/ClusterResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create cluster",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.post"
      }
    },
    "/cluster/{clusterKey}": {
      "delete": {
        "description": "Delete an existing cluster",
        "parameters": [
          {
            "description": "the cluster key",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "7ef80556-60bb-46bd-4cec-f4e2533aa75c"
          },
          {
            "description": "the current checksum of the cluster to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete cluster",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.clusterKey.delete"
      },
      "get": {
        "description": "Get details for an existing cluster",
        "parameters": [
          {
            "description": "the cluster key",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "7ef80556-60bb-46bd-4cec-f4e2533aa75c"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single cluster",
            "schema": {
              "$ref": "#/definitions/ClusterResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get cluster",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.clusterKey.get"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Modify an existing cluster",
        "parameters": [
          {
            "description": "the cluster key",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "5074fe62-821e-4034-55bd-b9caa09af2a1"
          },
          {
            "description": "the cluster to modify",
            "in": "body",
            "name": "cluster",
            "required": true,
            "schema": {
              "$ref": "#/definitions/Cluster"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing the modified cluster",
            "schema": {
              "$ref": "#/definitions/ClusterResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "modify cluster",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.clusterKey.put"
      }
    },
    "/cluster/{clusterKey}/instances": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Add a new instance to a cluster",
        "parameters": [
          {
            "description": "the cluster to add the instance to",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          },
          {
            "description": "the instance to add",
            "in": "body",
            "name": "instance",
            "required": true,
            "schema": {
              "$ref": "#/definitions/Instance"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created instance",
            "schema": {
              "$ref": "#/definitions/InstanceResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "add instance",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.clusterKey.instances.post"
      }
    },
    "/cluster/{clusterKey}/instances/{instanceIdentifier}": {
      "delete": {
        "description": "Remove an instance from a cluster",
        "parameters": [
          {
            "description": "the current checksum of the instance to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          },
          {
            "description": "the cluster to remove an instance from",
            "in": "path",
            "name": "clusterKey",
            "required": true,
            "type": "string",
            "x-example": "7ef80556-60bb-46bd-4cec-f4e2533aa75c"
          },
          {
            "description": "the instance to remove, identified as <host>:<port>",
            "in": "path",
            "name": "instanceIdentifier",
            "required": true,
            "type": "string",
            "x-example": "foo-1.useast.test.com:8080"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "remove instance",
        "tags": [
          "Cluster"
        ],
        "operationId": "cluster.clusterKey.instances.instanceIdentifier.delete"
      }
    },
    "/domain": {
      "get": {
        "description": "Get a list of domains",
        "parameters": [
          {
            "description": "A JSON encoded array of DomainFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any DomainFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of domains",
            "schema": {
              "$ref": "#/definitions/MultiDomainResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get domains",
        "tags": [
          "Domain"
        ],
        "operationId": "domain.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new domain",
        "parameters": [
          {
            "description": "the domain to create",
            "in": "body",
            "name": "domain",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DomainCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created zone",
            "schema": {
              "$ref": "#/definitions/DomainResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create domain",
        "tags": [
          "Domain"
        ],
        "operationId": "domain.post"
      }
    },
    "/domain/{domainKey}": {
      "delete": {
        "description": "Delete an existing domain",
        "parameters": [
          {
            "description": "the domain key",
            "in": "path",
            "name": "domainKey",
            "required": true,
            "type": "string",
            "x-example": "48cf1c9b-f027-4223-b405-d48018ffb900"
          },
          {
            "description": "the current checksum of the domain to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete domain",
        "tags": [
          "Domain"
        ],
        "operationId": "domain.domainKey.delete"
      },
      "get": {
        "description": "Get details for a single domain",
        "parameters": [
          {
            "description": "the domain key",
            "in": "path",
            "name": "domainKey",
            "required": true,
            "type": "string",
            "x-example": "48cf1c9b-f027-4223-b405-d48018ffb900"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single domain",
            "schema": {
              "$ref": "#/definitions/DomainResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get domain",
        "tags": [
          "Domain"
        ],
        "operationId": "domain.domainKey.get"
      }
    },
    "/listener": {
      "get": {
        "description": "Get a list of listeners",
        "parameters": [
          {
            "description": "A JSON encoded array of ListenerFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any ListenerFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of listeners",
            "schema": {
              "$ref": "#/definitions/MultiListenerResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "list listeners",
        "tags": [
          "Listener"
        ],
        "operationId": "listener.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new listener",
        "parameters": [
          {
            "description": "the listener to create",
            "in": "body",
            "name": "listener",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ListenerCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created listener",
            "schema": {
              "$ref": "#/definitions/ListenerResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create listener",
        "tags": [
          "Listener"
        ],
        "operationId": "listener.post"
      }
    },
    "/listener/{listenerKey}": {
      "delete": {
        "description": "Delete existing listener",
        "parameters": [
          {
            "description": "the listener key",
            "in": "path",
            "name": "listenerKey",
            "required": true,
            "type": "string",
            "x-example": "72c86057-ee8d-4a2b-a3a7-760fbd1d3b9f"
          },
          {
            "description": "the current checksum of the listener to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Listener"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete listener",
        "tags": [
          "Listener"
        ],
        "operationId": "listener.listenerKey.delete"
      },
      "get": {
        "description": "Get details for a single listener",
        "parameters": [
          {
            "description": "the listener key",
            "in": "path",
            "name": "listenerKey",
            "required": true,
            "type": "string",
            "x-example": "72c86057-ee8d-4a2b-a3a7-760fbd1d3b9f"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single listener",
            "schema": {
              "$ref": "#/definitions/ListenerResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get listener",
        "tags": [
          "Listener"
        ],
        "operationId": "listener.listenerKey.get"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Modify an existing listener",
        "parameters": [
          {
            "description": "the listener key",
            "in": "path",
            "name": "listenerKey",
            "required": true,
            "type": "string",
            "x-example": "5074fe62-821e-4034-55bd-b9caa09af2a1"
          },
          {
            "description": "the listener to modify",
            "in": "body",
            "name": "listener",
            "required": true,
            "schema": {
              "$ref": "#/definitions/Listener"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing the modified cluster",
            "schema": {
              "$ref": "#/definitions/ListenerResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "modify listener",
        "tags": [
          "Listener"
        ],
        "operationId": "listener.listenerKey.put"
      }
    },
    "/proxy": {
      "get": {
        "description": "Get a list of proxies",
        "parameters": [
          {
            "description": "A JSON encoded array of ProxyFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any ProxyFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of proxies",
            "schema": {
              "$ref": "#/definitions/MultiProxyResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "list proxies",
        "tags": [
          "Proxy"
        ],
        "operationId": "proxy.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new proxy",
        "parameters": [
          {
            "description": "the proxy to create",
            "in": "body",
            "name": "proxy",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ProxyCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created proxy",
            "schema": {
              "$ref": "#/definitions/ProxyResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create proxy",
        "tags": [
          "Proxy"
        ],
        "operationId": "proxy.post"
      }
    },
    "/proxy/{proxyKey}": {
      "delete": {
        "description": "Delete existing proxy",
        "parameters": [
          {
            "description": "the proxy key",
            "in": "path",
            "name": "proxyKey",
            "required": true,
            "type": "string",
            "x-example": "72c86057-ee8d-4a2b-a3a7-760fbd1d3b9f"
          },
          {
            "description": "the current checksum of the proxy to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Proxy"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete proxy",
        "tags": [
          "Proxy"
        ],
        "operationId": "proxy.proxyKey.delete"
      },
      "get": {
        "description": "Get details for a single proxy",
        "parameters": [
          {
            "description": "the proxy key",
            "in": "path",
            "name": "proxyKey",
            "required": true,
            "type": "string",
            "x-example": "72c86057-ee8d-4a2b-a3a7-760fbd1d3b9f"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single proxy",
            "schema": {
              "$ref": "#/definitions/ProxyResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get proxy",
        "tags": [
          "Proxy"
        ],
        "operationId": "proxy.proxyKey.get"
      }
    },
    "/route": {
      "get": {
        "description": "Get a list of routes",
        "parameters": [
          {
            "description": "A JSON encoded array of RouteFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any RouteFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of routes",
            "schema": {
              "$ref": "#/definitions/MultiRouteResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get routes",
        "tags": [
          "Route"
        ],
        "operationId": "route.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new route",
        "parameters": [
          {
            "description": "the route to create",
            "in": "body",
            "name": "route",
            "required": true,
            "schema": {
              "$ref": "#/definitions/RouteCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created route",
            "schema": {
              "$ref": "#/definitions/RouteResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create route",
        "tags": [
          "Route"
        ],
        "operationId": "route.post"
      }
    },
    "/route/{routeKey}": {
      "delete": {
        "description": "Delete an existing route",
        "parameters": [
          {
            "description": "the route key",
            "in": "path",
            "name": "routeKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          },
          {
            "description": "the current checksum of the route to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete route",
        "tags": [
          "Route"
        ],
        "operationId": "route.routeKey.delete"
      },
      "get": {
        "description": "Get details for an existing route",
        "parameters": [
          {
            "description": "the route key",
            "in": "path",
            "name": "routeKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single route",
            "schema": {
              "$ref": "#/definitions/RouteResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get route",
        "tags": [
          "Route"
        ],
        "operationId": "route.routeKey.get"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Modify an existing route",
        "parameters": [
          {
            "description": "the route key",
            "in": "path",
            "name": "routeKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          },
          {
            "description": "the route to modify",
            "in": "body",
            "name": "route",
            "required": true,
            "schema": {
              "$ref": "#/definitions/Route"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing the modified route",
            "schema": {
              "$ref": "#/definitions/RouteResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "modify route",
        "tags": [
          "Route"
        ],
        "operationId": "route.routeKey.put"
      }
    },
    "/shared_rules": {
      "get": {
        "description": "Get a list of shared_rules",
        "parameters": [
          {
            "description": "A JSON encoded array of SharedRulesFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any SharedRulesFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a list of shared_rules",
            "schema": {
              "$ref": "#/definitions/MultiSharedRulesResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get shared_rules",
        "tags": [
          "Shared Rules"
        ],
        "operationId": "shared_rules.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new shared_rules object",
        "parameters": [
          {
            "description": "the shared_rules object to create",
            "in": "body",
            "name": "shared_rules",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SharedRulesCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the newly created shared_rules object",
            "schema": {
              "$ref": "#/definitions/SharedRulesResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create shared_rules",
        "tags": [
          "Shared Rules"
        ],
        "operationId": "shared_rules.post"
      }
    },
    "/shared_rules/{sharedRulesKey}": {
      "delete": {
        "description": "Delete an existing shared_rules object",
        "parameters": [
          {
            "description": "the shared_rules key",
            "in": "path",
            "name": "sharedRulesKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          },
          {
            "description": "the current checksum of the shared_rules to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete shared_rules object",
        "tags": [
          "Route"
        ],
        "operationId": "shared_rules.sharedRulesKey.delete"
      },
      "get": {
        "description": "Get details for an existing shared_rules object",
        "parameters": [
          {
            "description": "the shared_rules key",
            "in": "path",
            "name": "sharedRulesKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single shared_rules object",
            "schema": {
              "$ref": "#/definitions/SharedRulesResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get shared_rules object",
        "tags": [
          "Shared Rules"
        ],
        "operationId": "shared_rules.sharedRulesKey.get"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "description": "Modify an existing shared_rules object",
        "parameters": [
          {
            "description": "the shared_rules key",
            "in": "path",
            "name": "sharedRulesKey",
            "required": true,
            "type": "string",
            "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
          },
          {
            "description": "the shared_rules object to modify",
            "in": "body",
            "name": "shared_rules",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SharedRules"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing the modified shared_rules object",
            "schema": {
              "$ref": "#/definitions/SharedRulesResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "modify shared_rules object",
        "tags": [
          "Shared Rules"
        ],
        "operationId": "shared_rules.sharedRulesKey.put"
      }
    },
    "/zone": {
      "get": {
        "description": "Get all zones. possibly with filters\n",
        "parameters": [
          {
            "description": "A JSON encoded array of ZoneFilter objects. The filter is taken\nas a union of intersections. In other words an object that matches\nevery constraint in any ZoneFilter will be included.\n",
            "in": "query",
            "name": "filters",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing an array of zones",
            "schema": {
              "$ref": "#/definitions/MultiZoneResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get a list of zones",
        "tags": [
          "Zone"
        ],
        "operationId": "zone.get"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "description": "Create a new zone.\n",
        "parameters": [
          {
            "description": "the zone to create",
            "in": "body",
            "name": "zone",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ZoneCreate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A result containing the newly created zone",
            "schema": {
              "$ref": "#/definitions/ZoneResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "create zone",
        "tags": [
          "Zone"
        ],
        "operationId": "zone.post"
      }
    },
    "/zone/{zoneKey}": {
      "delete": {
        "description": "Delete a zone.\n",
        "parameters": [
          {
            "description": "the zone key",
            "in": "path",
            "name": "zoneKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          },
          {
            "description": "the current checksum of the zone to be deleted",
            "in": "query",
            "name": "checksum",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f07240700b9"
          }
        ],
        "responses": {
          "200": {
            "description": "an empty result",
            "schema": {
              "$ref": "#/definitions/Empty"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "delete zone",
        "tags": [
          "Zone"
        ],
        "operationId": "zone.zoneKey.delete"
      },
      "get": {
        "description": "Get details for a single zone\n",
        "parameters": [
          {
            "description": "the zone key",
            "in": "path",
            "name": "zoneKey",
            "required": true,
            "type": "string",
            "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
          }
        ],
        "responses": {
          "200": {
            "description": "a result containing a single zone",
            "schema": {
              "$ref": "#/definitions/ZoneResult"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "summary": "get zone",
        "tags": [
          "Zone"
        ],
        "operationId": "zone.zoneKey.get"
      }
    }
  },
  "definitions": {
    "AccessToken": {
      "properties": {
        "access_token_key": {
          "type": "string"
        },
        "checksum": {
          "type": "string"
        },
        "created_at": {
          "description": "A timestamp that marks when a user was deleted. It is in the format\nyyyy-mm-ddThh:mm:ss.SZ. The timezone will always be UTC.\n",
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "signed_token": {
          "description": "This will be set only when an AccessToken is initially created\n",
          "type": "string"
        },
        "user_key": {
          "type": "string"
        }
      },
      "required": [
        "access_token_key",
        "description",
        "user_key",
        "created_at",
        "checksum"
      ],
      "type": "object"
    },
    "AccessTokenDescription": {
      "properties": {
        "description": {
          "type": "string"
        }
      },
      "required": [
        "description"
      ],
      "type": "object"
    },
    "AllConstraints": {
      "properties": {
        "dark": {
          "$ref": "#/definitions/ClusterConstraints"
        },
        "light": {
          "$ref": "#/definitions/ClusterConstraints"
        },
        "tap": {
          "$ref": "#/definitions/ClusterConstraints"
        }
      },
      "required": [
        "light"
      ],
      "type": "object"
    },
    "CORSConfig": {
      "description": "Experimental: Controls simple CORS responses for the associated domain.\nThe configurable properties map closely to the CORS specification which\nshould be referenced for a full discussion on their meaning:\nhttps://www.w3.org/TR/cors/ or https://developer.mozilla.org/docs/Web/HTTP/Access_control_CORS.\n",
      "properties": {
        "allow_credentials": {
          "description": "Indicates whether the response to request can be exposed when the\nomit credentials flag is unset\nhttps://www.w3.org/TR/cors/#access-control-allow-credentials-response-header.\n",
          "type": "boolean"
        },
        "allowed_headers": {
          "description": "Specifies what headers are allowed to be set when a request is made.\nhttps://www.w3.org/TR/cors/#access-control-allow-headers-response-header.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "allowed_methods": {
          "description": "Indicates which HTTP request types may be used to call an endpoint.\nhttps://www.w3.org/TR/cors/#access-control-allow-methods-response-header.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "allowed_origins": {
          "description": "Must contain a single element specifying the domain (origin) allowed\nto make requsets to this domain. If any origin is acceptable '*' may\nbe used as a wildcard https://www.w3.org/TR/cors/#origin-request-header,\nhttps://www.w3.org/TR/cors/#access-control-allow-origin-response-header.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "exposed_headers": {
          "description": "Indicates which response headers may be accessed from the browser.\nhttps://www.w3.org/TR/cors/#http-access-control-expose-headers.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "max_age": {
          "description": "Sets how long (in seconds) the response to a preflight request may be\ncached. A value of -1 will disable caching. https://www.w3.org/TR/cors/#access-control-max-age-response-header.\n",
          "type": "integer"
        }
      },
      "required": [
        "allowed_origins",
        "allowed_methods"
      ],
      "type": "object"
    },
    "CertKeyPathPair": {
      "description": "A key/cert pair that will be served when a domain terminates a SSL/TLS\nrequest.  Paths should be absolute and accessible to the user running\nthe proxy instance.\n",
      "properties": {
        "certificate_path": {
          "description": "Path to a certificate in the PEM format for the domain. If multiple\ncertificates need to be specified then should be contained in this file\nin the following order: first the primary certificate followed by any\nintermediary certificats.\n",
          "type": "string"
        },
        "key_path": {
          "description": "Path to a file with the secret key in the PEM format for the domain.\n",
          "type": "string"
        }
      },
      "required": [
        "certificate_path",
        "key_path"
      ],
      "type": "object"
    },
    "ChangeDescription": {
      "properties": {
        "actor_key": {
          "description": "The user who made the change.",
          "type": "string",
          "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
        },
        "at": {
          "description": "When the change took place in milliseconds since the Unix epoch.",
          "format": "int64",
          "type": "number"
        },
        "comment": {
          "description": "A description of the change.",
          "type": "string"
        },
        "diffs": {
          "description": "A collection of attribute updates that compose this change.",
          "items": {
            "$ref": "#/definitions/ChangeEntry"
          },
          "type": "array"
        },
        "txn": {
          "description": "A unique identifier for all this transaction. It is shared by all\nattribute updates within a change.\n",
          "type": "string",
          "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
        }
      },
      "type": "object"
    },
    "ChangeEntry": {
      "properties": {
        "change_type": {
          "description": "Whether the value was added or removed to the object.",
          "enum": [
            "addition",
            "removal"
          ],
          "type": "string"
        },
        "object_key": {
          "description": "An ID uniquely identifying the object being changed.",
          "type": "string",
          "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
        },
        "object_type": {
          "description": "The name of the object being being altered.",
          "enum": [
            "org",
            "user",
            "zone",
            "proxy",
            "domain",
            "route",
            "shared_rules",
            "cluster"
          ],
          "type": "string"
        },
        "path": {
          "description": "A dot-separated / bracket-indexed path to the field changed on the object.",
          "type": "string",
          "x-example": "cluster.instance[10.0.1.5:8080].metadata[pod-template-hash]"
        },
        "value": {
          "description": "The value that has been added or removed to the object at the attribute\npath indicated in path.\n",
          "type": "string"
        },
        "zone_key": {
          "description": "The zone this object is located in.",
          "type": "string",
          "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
        }
      },
      "type": "object"
    },
    "CircuitBreakers": {
      "description": "Provides limits on various parameters to protect clusters against sudden\nsurges in traffic.\n",
      "properties": {
        "max_connections": {
          "description": "Maximum number of connections that will be established to all\ninstances in a cluster within a proxy. If set to 0, no new connections\nwill be created. If not specified, defaults to 1024.\n",
          "type": "integer"
        },
        "max_pending_requests": {
          "description": "Maximum number of requests that will be queued while waiting on a\nconnection pool to a cluster within a proxy. If set to 0, no requests\nwill be queued. If not specified, defaults to 1024.\n",
          "type": "integer"
        },
        "max_requests": {
          "description": "Maximum number of requests that can be outstanding to all instances in\na cluster within  a proxy. Only applicable to HTTP/2 traffic since\nHTTP/1.1 clusters are governed by the maximum connections circuit\nbreaker. If set to 0, no requests will be made. If not specified,\ndefaults to 1024.\n",
          "type": "integer"
        },
        "max_retries": {
          "description": "Maximum number of retries that can be outstanding to all instances in\na cluster within a proxy. If set to 0, requests will not be retried.\nIf not specified, defaults to 3.\n",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "Cluster": {
      "allOf": [
        {
          "$ref": "#/definitions/ClusterCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "cluster_key": {
              "type": "string"
            }
          },
          "required": [
            "cluster_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "ClusterConstraint": {
      "properties": {
        "cluster_key": {
          "type": "string"
        },
        "constraint_key": {
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "properties": {
          "$ref": "#/definitions/Metadata"
        },
        "response_data": {
          "allOf": [
            {
              "$ref": "#/definitions/ResponseData"
            }
          ],
          "description": "When a request is served by a cluster selected by this constraint annotate\nthe response with the information specified within this ResponseData\nobject. It's possible that multiple response data configurations will\napply; if that's the case then the values from ClusterConstarint takes\nprecedence over those from a Route or SharedRules object.\n"
        },
        "weight": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ClusterConstraints": {
      "items": {
        "$ref": "#/definitions/ClusterConstraint"
      },
      "type": "array"
    },
    "ClusterCreate": {
      "properties": {
        "circuit_breakers": {
          "$ref": "#/definitions/CircuitBreakers"
        },
        "health_checks": {
          "$ref": "#/definitions/HealthChecks"
        },
        "instances": {
          "$ref": "#/definitions/Instances"
        },
        "name": {
          "type": "string"
        },
        "outlier_detection": {
          "$ref": "#/definitions/OutlierDetection"
        },
        "require_tls": {
          "description": "If set, requests to this collection of hosts will be made via HTTPS.\nAt this time neither certificate validation and certificate pinning\nare supported for proxy clients of this cluster.\n",
          "type": "boolean"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "zone_key",
        "name"
      ],
      "type": "object"
    },
    "ClusterFilter": {
      "properties": {
        "cluster_key": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ClusterResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Cluster"
        }
      },
      "type": "object"
    },
    "CohortSeed": {
      "properties": {
        "name": {
          "description": "The name of the cookie, the header field, or the query argument to\nbe checked for a cohort seed value.\n",
          "type": "string"
        },
        "type": {
          "description": "Where a request's cohort seed will be drawn from.",
          "enum": [
            "header",
            "cookie",
            "query"
          ],
          "type": "string"
        },
        "use_zero_value_seed": {
          "description": "If true, requests with a seed source which resolves to an empty value\nwill still be grouped and routed consistently. This means a misspelled\nor missing seed source on a request will sort all such traffic into a\nsingle backend. This could result in all traffic being assigned to a\nbackend intended for only a small percentage of traffic. Use with\ncaution.\n",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CookieDatum": {
      "description": "This describes a cookie that should be set in response to a HTTP request.\n",
      "properties": {
        "domain": {
          "description": "Specifies the hosts to hich a cookie will be sent. Maps directly to a\ncookie's 'Domain' attribute.\n",
          "type": "string"
        },
        "expires_in_sec": {
          "description": "This indicates how long a cookie will be valid, in seconds. If not set the\ndefault is to provide no expiration information. If set to 0 the cookie will\nhave an 'Expires' attribute set to 'Mon, 1 Jan 0001 12:00:00 UTC'. For values\ngreater than 0 the cookie's 'Max-Age' attribute will be set to that value.\n",
          "type": "integer"
        },
        "http_only": {
          "description": "If set the cookie value will not be accessible via Document.cookie. Maps\ndirectly to 'HttpOnly' attribute.\n",
          "type": "boolean"
        },
        "name": {
          "description": "The name of the cookie that will be attached to the response sent.",
          "type": "string"
        },
        "path": {
          "description": "Specifies the path a cookie will be associated with. Maps directly to\nthe 'Path' attribute.\n",
          "type": "string"
        },
        "same_site": {
          "description": "Allows assertions how a cookie should behave wend making cross-site requests.\nMaps directly to 'SameSite' attribute. If unset no guidance will be included\nin the cookie.\n",
          "enum": [
            "Strict",
            "Lax"
          ],
          "type": "string"
        },
        "secure": {
          "description": "If set the cookie will only be sent on subsequent requests when accessing\na server via HTTPS. Maps directly to 'Secure' attribute.\n",
          "type": "boolean"
        },
        "value": {
          "description": "A literal value to send as the cookie value or a reference to\nsome metadatum value set on the Cluster Intsance that handles\na specific request.\n",
          "type": "string"
        },
        "value_is_literal": {
          "description": "If true then the value attribute is treated as a literal and no attempt\nto resolve to a server metadatum.\n",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Domain": {
      "allOf": [
        {
          "$ref": "#/definitions/DomainCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "domain_key": {
              "type": "string"
            }
          },
          "required": [
            "domain_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "DomainCreate": {
      "properties": {
        "aliases": {
          "description": "A set of alternate names that this Domain may be referenced by. May\nstart ('*.') or end ('.*') with a wildcard.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "checksum": {
          "type": "string"
        },
        "cors_config": {
          "$ref": "#/definitions/CORSConfig"
        },
        "domain_key": {
          "type": "string"
        },
        "force_https": {
          "description": "If set to true, requests must use TLS. If a request is not using TLS, (as determined by\nthe scheme or the presence of X-Forwarded-Proto header), a 301 redirect will be sent\ntelling the client to use HTTPS.\n",
          "type": "boolean"
        },
        "gzip_enabled": {
          "description": "Experimental: if set to true will enable gzip compression on data that passes trough this domain",
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "port": {
          "type": "integer"
        },
        "redirects": {
          "items": {
            "$ref": "#/definitions/Redirect"
          },
          "type": "array"
        },
        "ssl_config": {
          "$ref": "#/definitions/SSLConfig"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "zone_key",
        "name",
        "port"
      ],
      "type": "object"
    },
    "DomainFilter": {
      "properties": {
        "domain_key": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "proxy_keys": {
          "description": "matches Domains with a superset of the specified proxy_keys. A\nslice with a single value of \"-\" will produce Domains with no linked\nProxies.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "DomainResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Domain"
        }
      },
      "type": "object"
    },
    "Empty": {
      "type": "object"
    },
    "Error": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "fields": {
          "type": "string"
        },
        "message": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "Filter": {
      "properties": {
        "absolute_match_only": {
          "description": "If set this will return ChangeEntry values with a path that matches\nthe attribute_path property exactly.\n",
          "type": "boolean"
        },
        "actor_key": {
          "description": "The user who made the change.",
          "type": "string",
          "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
        },
        "attribute_path": {
          "description": "A dot-separated / bracket-indexed path to the field changed on the\nobject. '%' may be used as a wildcard.\n",
          "type": "string",
          "x-example": "cluster.instance[%].metadata[app-name]"
        },
        "attribute_value": {
          "description": "The value that has been added or removed to the object at the attribute\npath indicated in path.\n",
          "type": "string"
        },
        "change_txn": {
          "description": "A unique identifier for all this transaction. It is shared by all\nattribute updates within a change.\n",
          "type": "string",
          "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
        },
        "change_type": {
          "description": "Whether the value was added or removed to the object.",
          "enum": [
            "addition",
            "removal"
          ],
          "type": "string"
        },
        "exclude_empty_values": {
          "description": "If set this will exclude ChangeEntry records that save the addition\nor removal of an empty value.\n",
          "type": "boolean"
        },
        "negative_match": {
          "description": "If set this filter will match the all ChangeEntry records that do\nNOT meet the constraints laid out in this Filter object.\n",
          "type": "boolean"
        },
        "object_key": {
          "description": "An ID uniquely identifying the object being changed.",
          "type": "string",
          "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
        },
        "object_type": {
          "description": "The name of the object being being altered.",
          "enum": [
            "org",
            "user",
            "zone",
            "proxy",
            "domain",
            "route",
            "shared_rules",
            "cluster"
          ],
          "type": "string"
        },
        "org_key": {
          "description": "The organization the objects being updated belong to.",
          "type": "string",
          "x-example": "1c7b1c5e-1a23-4d04-5cb4-eccea4d5994c"
        },
        "time_range": {
          "$ref": "#/definitions/TimeRange"
        },
        "zone_key": {
          "description": "The zone this object is located in.",
          "type": "string",
          "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
        }
      },
      "type": "object"
    },
    "FilterProducts": {
      "properties": {
        "and": {
          "description": "An array of changelog filters that will be joined via logical AND.",
          "items": {
            "$ref": "#/definitions/Filter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "FilterSums": {
      "properties": {
        "or": {
          "description": "An array of changelog filters that will be joined via logical OR.",
          "items": {
            "$ref": "#/definitions/FilterProducts"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "HTTPHealthCheck": {
      "properties": {
        "host": {
          "description": "The value of the host header in the HTTP health check request.\nIf left empty, the name of the cluster being health checked\nwill be used.\n",
          "type": "string"
        },
        "path": {
          "description": "Specifies the HTTP path that will be requested during health\nchecking.\n",
          "type": "string"
        },
        "request_headers_to_add": {
          "allOf": [
            {
              "$ref": "#/definitions/Metadata"
            }
          ],
          "description": "Specifies a list of HTTP headers that should be added to each request\nsent to the health checked cluster.\n"
        },
        "service_name": {
          "description": "An optional service name parameter which is used to validate\nthe identity of the health checked cluster.\n",
          "type": "string"
        }
      },
      "type": "object"
    },
    "HeaderConstraint": {
      "description": "Indicates that a request's headers should meet some requirement before being\nselected for a rewrite. Must have zore or one elements.\n",
      "properties": {
        "case_sensitive": {
          "description": "If set, the header value check will be case sensitive.",
          "type": "boolean"
        },
        "invert": {
          "description": "If set, the header constraint will succeed if the match described faile.\n",
          "type": "boolean"
        },
        "name": {
          "description": "The header that is being checked. This must match the regexp \"^[0-9a-zA-Z-]+$\".\nThis is checked in a case insensitive manner.\n",
          "type": "string"
        },
        "value": {
          "description": "If set the header's value will be compared to this. The default is to\nmake case insensitive comparisons.\n",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "HeaderDatum": {
      "description": "This describes a HTTP header that should be attached to requests.\n",
      "properties": {
        "name": {
          "description": "The name of the header that will be attached to the response sent.\nThis is case insensitive.\n",
          "type": "string"
        },
        "value": {
          "description": "A literal value to send as the header value or a reference to\nsome metadatum value set on the Cluster Intsance that handles\na specific request. If this value is empty after looking up an\nInstance metadatum value no header will be sent.\n",
          "type": "string"
        },
        "value_is_literal": {
          "description": "If true then the value attribute is treated as a literal and no attempt\nto resolve instance metadatum to find a value.\n",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "HealthCheck": {
      "description": "Configures active health checking for every instance in a cluster.\n",
      "properties": {
        "health_checker": {
          "description": "Defines the type of health checker to use. Only a single health\nchecker can be defined per HealthCheck.\n",
          "properties": {
            "http_health_check": {
              "$ref": "#/definitions/HTTPHealthCheck"
            },
            "tcp_health_check": {
              "$ref": "#/definitions/TCPHealthCheck"
            }
          },
          "type": "object"
        },
        "healthy_edge_interval_msec": {
          "description": "Interval used for the first health check right after a host is marked\nas healthy. For subsequent health checks, the proxy will shift back to\nusing the standard health check interval(\\'interval_msec\\') that is\ndefined. Defaults to the same value as \\'interval_msec\\' if not\nspecified.\n",
          "type": "integer"
        },
        "healthy_threshold": {
          "description": "The number of healthy health checks required before a host is marked\nhealthy. Note that during startup, only a single successful health\ncheck is required to mark a host healthy.\n",
          "type": "integer"
        },
        "interval_jitter_msec": {
          "description": "An optional jitter amount that is added to each interval value\ncalculated by the proxy. If not specified, defaults to 0.\n",
          "type": "integer"
        },
        "interval_msec": {
          "description": "The interval between health checks. The first round of health checks\nwill occur during startup before any traffic is routed to a cluster.\nThis means that the \\'no_traffic_interval_msec\\' value will be used as\nthe first interval of health checks.\n",
          "type": "integer"
        },
        "no_traffic_interval_msec": {
          "description": "Interval used when a cluster has never had traffic routed to it. It\nallows cluster information to be kept up to date, without sending a\npotentially large amount of active health checking traffic for no\nreason. Once a cluster has been used for traffic routing, The proxy\nwill shift back to using the standard health check interval that is\ndefined. Note that this interval takes precedence over any other.\nDefaults to 60s.\n",
          "type": "integer"
        },
        "reuse_connection": {
          "description": "Whether or not to reuse health check connections between health checks.\nDefault is true.\n",
          "type": "boolean"
        },
        "timeout_msec": {
          "description": "The time to wait for a health check response. If the timeout is\nreached without a response, the health check attempt will be\nconsidered a failure. This is a required field and must be greater\nthan 0.\n",
          "type": "integer"
        },
        "unhealthy_edge_interval_msec": {
          "description": "Interval used for the first health check right after a host is marked\nas unhealthy. For subsequent health checks, the proxy will shift back\nto using either \\'unhealthy_interval_msec\\' if present or the standard\nhealth check interval, \\'interval_msec\\'.\n",
          "type": "integer"
        },
        "unhealthy_interval_msec": {
          "description": "Interval used for hosts that are marked as unhealthy. As soon as the\nhost is marked as healthy, The proxy will shift back to using the\nstandard health check interval that is defined. This defaults to the\nsame value as \\'interval_msec\\' if not specified.\n",
          "type": "integer"
        },
        "unhealthy_threshold": {
          "description": "The number of unhealthy health checks required before a host is\nmarked unhealthy. Note that for *http* health checking, if a host\nresponds with 503, this threshold is ignored and the host is\nconsidered unhealthy immediately.\n",
          "type": "integer"
        }
      },
      "required": [
        "timeout_msec",
        "interval_msec",
        "unhealthy_threshold",
        "healthy_threshold",
        "health_checker"
      ],
      "type": "object"
    },
    "HealthChecks": {
      "items": {
        "$ref": "#/definitions/HealthCheck"
      },
      "type": "array"
    },
    "Instance": {
      "properties": {
        "host": {
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "port": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "InstanceResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Instance"
        }
      },
      "type": "object"
    },
    "Instances": {
      "items": {
        "$ref": "#/definitions/Instance"
      },
      "type": "array"
    },
    "Listener": {
      "allOf": [
        {
          "$ref": "#/definitions/ListenerCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "listener_key": {
              "type": "string",
              "x-example": "9cd24183-f848-48f8-6f55-0f0724070000"
            }
          },
          "required": [
            "listener_key",
            "zone_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "ListenerCreate": {
      "properties": {
        "domain_keys": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-example": [
            "9cd24183-f848-48f8-6f55-0f0724070000",
            "9cd24183-f848-48f8-6f55-0f0724070001"
          ]
        },
        "ip": {
          "description": "the interface this listener should bind to.",
          "type": "string",
          "x-example": "0.0.0.0"
        },
        "name": {
          "type": "string",
          "x-example": "http-web"
        },
        "port": {
          "description": "the port this listener should bind to.",
          "type": "integer",
          "x-example": 80
        },
        "protocol": {
          "description": "the protocol this listener will handle. http and http2 configure the listener to only\nprocess requests of that type. http_auto will adapt to HTTP/1.1 and HTTP/2 as needed.\ntcp configures the listener to be a tcp proxy\n",
          "enum": [
            "http",
            "http2",
            "http_auto",
            "tcp"
          ],
          "type": "string"
        },
        "tracing_config": {
          "$ref": "#/definitions/TracingConfig"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "listener_key",
        "name",
        "host",
        "port",
        "protocol"
      ],
      "type": "object"
    },
    "ListenerResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Listener"
        }
      },
      "type": "object"
    },
    "Match": {
      "description": "Represents a mapping of request attributes to constraints on a cluster\nusing different matching schemes.\n\nCertain combinations of `kind` and `behavior` are not allowed\n  | kind | behavior |\n  | ---- | -------- |\n  | query | regex |\n  | query | range |\n  | cookie | range |\n",
      "properties": {
        "behavior": {
          "description": "Defines how a request attribute should be matched. If not specified,\ndefaults to `exact`. Valid values are\n  * exact\n  * regex\n  * range\n  * prefix\n  * suffix\n",
          "type": "string"
        },
        "from": {
          "allOf": [
            {
              "$ref": "#/definitions/Metadatum"
            }
          ],
          "description": "The request attribute key and value to match. `key` must always be\ndefined while `value` can be unspecified (only if behavior is set to\n`exact`) to indicate that all values should be matched. If to.value\nis also unspecified, the matched value of the request will be used as\na constraint on the destination cluster.\n\n\\# Behavior\n  * `regex` if To.Value is unspecified, `value` must contain one and\n  only one subgroup. Otherwise, `value` must not be empty.\n  * `range` `value` must be specified and must be of the format\n  `[start_integer, end_integer)`. Start and end must be valid integer\n  values and `end_integer` must be greater than `start_integer`.\n  * `prefix`/`suffix` `value` must be specified\n\n\\# Kind\n  * `cookie` does not support `range` behavior\n  * `query` does not support `regex` behavior\n"
        },
        "kind": {
          "description": "Defines the attribute by which a request should be matched on. Valid\nvalues are\n  * cookie\n  * header\n  * query (for query parameter)\n",
          "type": "string"
        },
        "to": {
          "allOf": [
            {
              "$ref": "#/definitions/Metadatum"
            }
          ],
          "description": "The constraints on a cluster that a matched request should map to. If\nto.key is specified and to.value is not, the matched from.value will\nbe used as a metadata constraint on instances in the destination\ncluster, keyed by to.key. If using `regex` behavior with multiple\nsubgroups in from.value, variables `$1` through `$n`, where n is the\nnumber of subgroups in the matching regex, can be used to interpolate\ncaptured matches in to.value.\n"
        }
      },
      "type": "object"
    },
    "Matches": {
      "items": {
        "$ref": "#/definitions/Match"
      },
      "type": "array"
    },
    "Metadata": {
      "items": {
        "$ref": "#/definitions/Metadatum"
      },
      "type": "array"
    },
    "Metadatum": {
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "MultiAccessTokens": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/AccessToken"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiClusterResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Cluster"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiDomainResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Domain"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiListenerResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Listener"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiProxyResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Proxy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiRouteResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Route"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiSharedRulesResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/SharedRules"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MultiZoneResult": {
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/Zone"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "OutlierDetection": {
      "description": "A form of passive health checking that dynamically determines whether\ninstances in a cluster are performing unlike others and preemptively\nremoves them from a load balancing set.\n",
      "properties": {
        "base_ejection_time_msec": {
          "description": "The base time that a host is ejected for. The real time is equal to\nthe base time multiplied by the number of times the host has been\nejected. Defaults to 30s. Setting this to 0 means that no host will\nbe ejected for longer than `interval_msec`.\n",
          "type": "integer"
        },
        "consecutive_5xx": {
          "description": "The number of consecutive 5xx responses before a consecutive 5xx ejection\noccurs. Defaults to 5. Setting this to 0 effectively turns off the\nconsecutive 5xx detector.\n",
          "type": "integer"
        },
        "consecutive_gateway_failure": {
          "description": "The number of consecutive gateway failures (502, 503, 504 status or\nconnection errors that are mapped to one of those status codes) before a\nconsecutive gateway failure ejection occurs. Defaults to 5. Setting this\nto 0 effectively turns off the consecutive gateway failure detector.\n",
          "type": "integer"
        },
        "enforcing_consecutive_5xx": {
          "description": "The % chance that a host will be actually ejected when an outlier status\nis detected through consecutive 5xx. This setting can be used to disable\nejection or to ramp it up slowly. Defaults to 100.\n",
          "type": "integer"
        },
        "enforcing_consecutive_gateway_failure": {
          "description": "The % chance that a host will be actually ejected when an outlier status\nis detected through consecutive gateway failures. This setting can be\nused to disable ejection or to ramp it up slowly. Defaults to 0.\n",
          "type": "integer"
        },
        "enforcing_success_rate": {
          "description": "The % chance that a host will be actually ejected when an outlier status\nis detected through success rate statistics. This setting can be used to\ndisable ejection or to ramp it up slowly. Defaults to 100.\n",
          "type": "integer"
        },
        "interval_msec": {
          "description": "The time interval between ejection analysis sweeps. This can result in\nboth new ejections due to success rate outlier detection as well as\nhosts being returned to service. Defaults to 10s and must be greater\nthan 0.\n",
          "type": "integer"
        },
        "max_ejection_percent": {
          "description": "The maximum % of an upstream cluster that can be ejected due to\noutlier detection. Defaults to 10% but will always eject at least one\nhost.\n",
          "type": "integer"
        },
        "success_rate_minimum_hosts": {
          "description": "The number of hosts in a cluster that must have enough request volume to\ndetect success rate outliers. If the number of hosts is less than this\nsetting, outlier detection via success rate statistics is not performed\nfor any host in the cluster. Defaults to 5. Setting this to 0 effectively\ntriggers the success rate detector regardless of the number of valid hosts\nduring an interval (as determined by `success_rate_request_volume`).\n",
          "type": "integer"
        },
        "success_rate_request_volume": {
          "description": "The minimum number of total requests that must be collected in one\ninterval (as defined by interval_msec) to include this host\nin success rate based outlier detection. If the volume is lower than this\nsetting, outlier detection via success rate statistics is not performed\nfor that host. Defaults to 100. Must be greater than 0.\n",
          "type": "integer"
        },
        "success_rate_stdev_factor": {
          "description": "This factor is used to determine the ejection threshold for success rate\noutlier ejection. The ejection threshold is the difference between the\nmean success rate, and the product of this factor and the standard\ndeviation of the mean success rate: mean - (stdev *\nsuccess_rate_stdev_factor). This factor is divided by a thousand to get a\ndouble. That is, if the desired factor is 1.9, the runtime value should\nbe 1900. Defaults to 1900. Setting this to 0 effectively turns off the\nsuccess rate detector.\n",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "PageDetails": {
      "properties": {
        "direction": {
          "description": "The direction walked from the ref_id when building this page.",
          "enum": [
            "before",
            "after"
          ],
          "type": "string"
        },
        "has_more": {
          "description": "Whether or not there are more entries to be requested after this page.",
          "type": "boolean"
        },
        "ref_id": {
          "description": "The ID used as a reference when building this page.",
          "type": "string"
        },
        "total_entries": {
          "description": "How many total entries would have been returned in the time window\nif it had not been paginated.\n",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "PaginatedChangeDescriptions": {
      "properties": {
        "details": {
          "$ref": "#/definitions/PaginationDetails"
        },
        "result": {
          "items": {
            "$ref": "#/definitions/ChangeDescription"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "PaginationDetails": {
      "properties": {
        "pagination": {
          "$ref": "#/definitions/PageDetails"
        }
      },
      "type": "object"
    },
    "Proxy": {
      "allOf": [
        {
          "$ref": "#/definitions/ProxyCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "proxy_key": {
              "type": "string"
            }
          },
          "required": [
            "proxy_key",
            "zone_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "ProxyCreate": {
      "properties": {
        "domain_keys": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "listener_keys": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "zone_key",
        "name"
      ],
      "type": "object"
    },
    "ProxyFilter": {
      "properties": {
        "domain_keys": {
          "description": "matches Proxies with a superset of the specified domain_keys. A\nslice with a single value of \"-\" will produce Proxies with no linked\nDomains.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "type": "string"
        },
        "proxy_key": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ProxyResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Proxy"
        }
      },
      "type": "object"
    },
    "Redirect": {
      "description": "Specifies how a URL within a domain should be rewritten when requested.\n",
      "properties": {
        "from": {
          "description": "A regexp that will be matched against the URL (not including the host/port). May include capture groups for reference in \"to.\"",
          "type": "string"
        },
        "header_constraints": {
          "items": {
            "$ref": "#/definitions/HeaderConstraint"
          },
          "type": "array"
        },
        "name": {
          "description": "A unique (to this Domain) name for the Redirect. Must match the regexp \"^[0-9a-zA-Z-]+$\"",
          "type": "string"
        },
        "redirect_type": {
          "description": "How this redirect should be presented via HTTP response code.",
          "enum": [
            "permanent",
            "temporary"
          ],
          "type": "string"
        },
        "to": {
          "description": "The new URL that will be constructed from the request. Capture groups from \"from\" may be referenced as \"$&lt;group number&gt;\" which begins at 1.",
          "type": "string"
        }
      },
      "required": [
        "name",
        "from",
        "to",
        "redirect_type"
      ],
      "type": "object"
    },
    "ResponseData": {
      "properties": {
        "cookies": {
          "items": {
            "$ref": "#/definitions/CookieDatum"
          },
          "type": "array"
        },
        "headers": {
          "items": {
            "$ref": "#/definitions/HeaderDatum"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RetryPolicy": {
      "description": "Number of times to retry a request and how long to wait before timing out.",
      "properties": {
        "num_retries": {
          "description": "Number of times to retry an upstream request. Note that the initial\nconnection attempt is not included in this number, hence 0 means initial\nattempt and no retries, and 1 means initial attempt plus one retry.\n",
          "format": "int64",
          "type": "integer"
        },
        "per_try_timeout_msec": {
          "description": "Time limit in milliseconds for a single attempt.",
          "format": "int64",
          "type": "integer"
        },
        "timeout_msec": {
          "description": "Total time limit in milliseconds for all attempts (including the initial attempt)\n",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "Route": {
      "allOf": [
        {
          "$ref": "#/definitions/RouteCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "route_key": {
              "type": "string"
            }
          },
          "required": [
            "route_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "RouteCreate": {
      "properties": {
        "checksum": {
          "type": "string"
        },
        "cohort_seed": {
          "$ref": "#/definitions/CohortSeed"
        },
        "domain_key": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "response_data": {
          "allOf": [
            {
              "$ref": "#/definitions/ResponseData"
            }
          ],
          "description": "When a request is served by this Route annotate the response with the\ninformation specified within this ResponseData object. It's possible\nthat multiple response data configurations will apply; if that's the\ncase then the values from Route take precedence over those from a\nSharedRules object.\n"
        },
        "retry_policy": {
          "$ref": "#/definitions/RetryPolicy"
        },
        "route_key": {
          "type": "string"
        },
        "rules": {
          "items": {
            "$ref": "#/definitions/Rule"
          },
          "type": "array"
        },
        "shared_rules_key": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "domain_key",
        "zone_key",
        "path",
        "shared_rules_key"
      ],
      "type": "object"
    },
    "RouteFilter": {
      "properties": {
        "domain_key": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "path_prefix": {
          "type": "string"
        },
        "route_key": {
          "type": "string"
        },
        "shared_rules_key": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "RouteResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Route"
        }
      },
      "type": "object"
    },
    "Rule": {
      "properties": {
        "cohort_seed": {
          "$ref": "#/definitions/CohortSeed"
        },
        "constraints": {
          "$ref": "#/definitions/AllConstraints"
        },
        "matches": {
          "$ref": "#/definitions/Matches"
        },
        "methods": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "rule_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SSLConfig": {
      "description": "Experimental: Specifies whether a domain should support SSL/TLS\nconnections from clients.  If not set the proxy will expect unencrypted HTTP\ntraffic.\n",
      "properties": {
        "cert_key_pairs": {
          "description": "SSLConfig must have one cert_key_pairs entry specified.",
          "items": {
            "$ref": "#/definitions/CertKeyPathPair"
          },
          "type": "array"
        },
        "cipher_filter": {
          "description": "An OpenSSL compatible filter string indicating the ciphers acceptable\nfor this proxy to use while communicating with clients. The default value\nis EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH. For more information\nsee https://wiki.openssl.org/index.php/Manual:Ciphers(1)\n",
          "type": "string"
        },
        "protocols": {
          "description": "A list of acceptable SSL/TLS protocol. The default values are TLSv1,\nTLSv1.1, TLSv1.2. Additional valid values are SSLv2 and SSLv3.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "cert_key_pairs"
      ],
      "type": "object"
    },
    "SharedRules": {
      "allOf": [
        {
          "$ref": "#/definitions/SharedRulesCreate"
        },
        {
          "properties": {
            "checksum": {
              "type": "string"
            },
            "shared_rules_key": {
              "type": "string"
            }
          },
          "required": [
            "shared_rules_key",
            "checksum"
          ],
          "type": "object"
        }
      ]
    },
    "SharedRulesCreate": {
      "properties": {
        "checksum": {
          "type": "string"
        },
        "cohort_seed": {
          "$ref": "#/definitions/CohortSeed"
        },
        "default": {
          "$ref": "#/definitions/AllConstraints"
        },
        "properties": {
          "$ref": "#/definitions/Metadata"
        },
        "response_data": {
          "allOf": [
            {
              "$ref": "#/definitions/ResponseData"
            }
          ],
          "description": "When a request is served by a Route that is part of this SharedRules\ngroup the response is annotated with the information specified within\nthis ResponseData object. It's possible that multiple response data\nconfigurations will apply; if that's the case then the values from\nthe applicable Route and ClusterConstarint takes precedence over those\nspecified here.\n"
        },
        "retry_policy": {
          "$ref": "#/definitions/RetryPolicy"
        },
        "rules": {
          "items": {
            "$ref": "#/definitions/Rule"
          },
          "type": "array"
        },
        "shared_rules_key": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "zone_key",
        "default"
      ],
      "type": "object"
    },
    "SharedRulesFilter": {
      "properties": {
        "name": {
          "type": "string"
        },
        "shared_rules_key": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SharedRulesResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/SharedRules"
        }
      },
      "type": "object"
    },
    "TCPHealthCheck": {
      "properties": {
        "receive": {
          "description": "An array of base64 encoded strings, each representing array of\nbytes that is expected in health check responses. When\nchecking the response, \"fuzzy\" matching is performed such that\neach binary block must be found, and in the order specified,\nbut not necessarily contiguously.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "send": {
          "description": "Base64 encoded string representing an array of bytes to be\nsent in health check requests. Leaving this field empty\nimplies a connect-only health check.\n",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TimeRange": {
      "properties": {
        "end": {
          "description": "The end of the window we want to see changes for; measured in\nmicroseconds since Unix Epoch.\n",
          "format": "int64",
          "type": "integer"
        },
        "start": {
          "description": "The beginning of the window we want to see changes for; measured in microseconds since Unix Epoch.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TracingConfig": {
      "description": "Configures tracing operations to be performed on the given listener\n",
      "properties": {
        "ingress": {
          "description": "Determines whether spans sent from this listener should be treated as ingress\nor egress operations.\n",
          "type": "boolean",
          "x-example": true
        },
        "request_headers_for_tags": {
          "description": "the headers specified here will be added to the generated spans as annotations\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-example": [
            "x-forwarded-for",
            "x-user-id"
          ]
        }
      },
      "type": "object"
    },
    "User": {
      "properties": {
        "checksum": {
          "type": "string"
        },
        "deleted_at": {
          "description": "A timestamp that marks when a user was deleted. It is in the format\nyyyy-mm-ddThh:mm:ss.SZ. The timezone will always be UTC.\n",
          "type": "string",
          "x-example": "2017-08-14T17:29:11.986438Z"
        },
        "login_email": {
          "type": "string"
        },
        "user_key": {
          "type": "string"
        }
      },
      "required": [
        "user_key",
        "login_email",
        "checksum"
      ],
      "type": "object"
    },
    "Zone": {
      "properties": {
        "checksum": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "required": [
        "zone_key",
        "name",
        "checksum"
      ],
      "type": "object"
    },
    "ZoneCreate": {
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "ZoneFilter": {
      "properties": {
        "name": {
          "type": "string"
        },
        "zone_key": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ZoneResult": {
      "properties": {
        "result": {
          "$ref": "#/definitions/Zone"
        }
      },
      "type": "object"
    }
  }
}